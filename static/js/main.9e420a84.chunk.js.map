{"version":3,"sources":["components/ColorPickerHistory.tsx","components/PinnedColors.tsx","drivers/Color.ts","BodyColorPicker.tsx","components/CanvasContainer.tsx","components/Grid.tsx","CanvasStack.tsx","Modal.tsx","ConfirmModal.tsx","drivers/UndoablePaintCanvas.ts","drivers/getRelativeClickPosition.tsx","components/SaveButton.tsx","Footer.tsx","components/DimensionPicker.tsx","components/LoadButton.tsx","NewPageModal.tsx","PaletteDictionary.tsx","PalettePicker.tsx","PaletteModal.tsx","drivers/useLongPress.tsx","SettingsModal.tsx","components/DropperIcon.tsx","components/PaletteIcon.tsx","HighlightableButton.tsx","ToolsBanner.tsx","App.tsx","index.tsx"],"names":["ColorPickerHistory","colorSelected","onColorPicked","colorHistory","setColorHistory","Box","className","direction","justify","wrap","gap","map","color","index","height","width","pad","bottom","Button","fill","size","onClick","style","backgroundColor","toHex","border","PinnedColors","pinnedColors","slice","HSLColor","hue","saturation","lightness","hsl","this","hslString","sep","indexOf","substr","split","hString","s","parseFloat","length","l","h","Math","round","PI","r","g","b","cMin","min","cMax","max","delta","abs","RGBColor","fromHSL","red","green","blue","rgb","RangeError","c","x","m","hex","Number","isInteger","TypeError","hexString","toString","fromHexString","rgbString","rgbChunks","rgbValues","R","parseInt","rString","gString","bString","fromRGB","a","r1","g1","b1","r2","g2","b2","NO_COLOR","BodyColorPicker","setColorAndTurnOffPicker","pickerMode","palette","useEffect","filter","currentColor","Equals","newColorHistory","unshift","CanvasContainer","onCanvasCreated","onTouchEvent","pixelDimensions","canvasRef","useRef","canvas","current","onInnerTouchEvent","event","backgroundSize","ref","onTouchEnd","onTouchMove","Grid","rootCanvas","context","getContext","clearRect","strokeStyle","lineWidth","xIncrement","xIndex","moveTo","lineTo","stroke","yIncrement","yIndex","clientWidth","clientHeight","CanvasStack","isGridShown","onCanvasTouch","stackProps","useState","setCanvas","Stack","Modal","onClose","children","heading","Layer","modal","full","onClickOutside","Text","icon","Close","ConfirmModal","onAccept","onCancel","message","cancelButtonText","acceptButtonText","alignSelf","label","primary","Symbol","iterator","toStringTag","KeyPairMap","keyPairMap","Map","keyA","keyB","value","set","clear","get","delete","callbackfn","thisArg","toRefMap","forEach","tempMap","innerMap","outerMap","keys","has","entries","values","lines","key","push","join","UndoablePaintCanvas","dimension","undoBuffer","cellExists","y","getPixelMap","UndoRedoBuffer","clone","addCurrent","undo","setPixelMap","redo","redoOne","undefined","fillColor","startColor","getColorAt","visited","floodFill","cellColor","AreColorsEqual","pixelMap","Error","PaintCanvas","DrawToCanvas","drawToCanvas","AreDimensionsCompatible","image","document","createElement","naturalWidth","naturalHeight","drawImage","setPixelsFromCanvas","xIntervals","yIntervals","mutableMap","data","getImageData","maybeColor","results","Array","elementResult","result","paintCanvas","fillStyle","fillRect","sqrt","touchToCoords","quantX","quantY","setColorAt","screenX","changedTouches","clientX","screenY","clientY","rect","target","getBoundingClientRect","clip","clippedX","left","clippedY","top","relativeX","relativeY","getRelativeClickPosition","scaledX","scaledY","floor","colorA","colorB","redoBuffer","maybeTop","getBufferLength","redid","pop","base","maxSize","buffer","maybeReverseState","SaveButton","anchorRef","onShareClick","fullScaleCanvas","drawToHigherResolutionCanvas","Promise","resolve","reject","toBlob","maybeBlob","blob","location","protocol","navigator","share","files","Object","freeze","File","type","canShare","title","catch","error","name","console","debug","toDataURL","href","click","Share","display","download","imageSmoothingEnabled","Footer","onAddButtonClicked","setSettingsMenuShown","gridArea","right","columns","count","align","Actions","Add","labelToValue","valueToLabel","1","8","10","12","14","16","18","20","22","24","options","DimensionPicker","onDimensionChange","Select","placeholder","onChange","option","LoadButton","setLoadedImage","imageName","setImageName","input","imagePromise","imageUrl","URL","createObjectURL","Image","src","onload","accept","NewPageModal","currentDimension","onCreateNew","loadedImage","setDimension","paletteColorDictionary","c64","cga","teletext","paletteNameDictionary","Teletext","PalettePicker","onPaletteChange","possiblePalettes","PaletteModal","setColor","setPinnedColors","setPalette","selectedPalette","onLongPressComplete","duration","onLongPressCancel","timeout","wasLongPress","cancelTimeout","clearTimeout","onPressDown","setTimeout","onPressUp","useLongPress","getButtonIndex","find","pinned","currentPinnedColors","maybeIndex","onTouchStart","isPinned","data-index","Pin","borderRadius","maybeIndexString","dataset","SettingsModal","resetMode","isDarkMode","CheckBox","toggle","checked","DropperIcon","props","StyledIcon","viewBox","a11yTitle","strokeWidth","d","PaletteIcon","xmlns","fillOpacity","cx","cy","HighlightableButton","isHighlighted","boxShadow","ToolsBanner","onToolChange","onPickerModeClick","onUndoClick","onRedoClick","onPaletteButtonClick","onGridButtonClick","onTrashClick","tool","rows","areas","start","end","Brush","Erase","Paint","History","Undo","Redo","Trash","useStickyBrush","defaultBrush","setTool","brush","setBrush","useCallback","App","setPixelDimensions","confirmModalParameters","createModal","setToolAndBrush","setPickerMode","setGridShown","isPaletteModalShown","setPaletteMenuShown","isNewPageModalShown","setCreateMenuShown","isSettingsMenuShown","darkMode","setDarkMode","paint","useMemo","isConfirmModalShown","Grommet","theme","grommet","themeMode","Header","interactiveChild","isPaletteMenuShown","coords","selectedColor","touchEvent","fillWithColor","Main","elevation","maybeLoadedImage","setPixelsFromImage","window","oncontextmenu","preventDefault","stopPropagation","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.9e420a84.chunk.js","sourcesContent":["import { Box, Button } from \"grommet\";\nimport { RGBColor } from \"../drivers/Color\";\n\nexport const ColorPickerHistory = ({\n  colorSelected,\n  onColorPicked,\n  colorHistory,\n  setColorHistory,\n}: {\n  setColorHistory: (history: RGBColor[]) => void;\n  colorHistory: RGBColor[];\n  colorSelected: RGBColor;\n  onColorPicked: (color: RGBColor) => void;\n}) => {\n\n  return (\n    <Box\n      className=\"ColorPickerHistory\"\n      direction=\"row\"\n      justify=\"start\"\n      wrap\n      gap=\"xxsmall\"\n    >\n      {colorHistory.map((color, index) => (\n        <Box\n          key={color.toHex()}\n          height=\"xxsmall\"\n          width=\"xxsmall\"\n          pad={{ bottom: \"xsmall\" }}\n        >\n          <Button\n            fill=\"vertical\"\n            size=\"small\"\n            onClick={() => onColorPicked(color)}\n            key={index}\n            style={{\n              backgroundColor: color.toHex(),\n              border: \"none\",\n            }}\n          ></Button>\n        </Box>\n      ))}\n    </Box>\n  );\n};\n","import { Box, Button } from \"grommet\";\nimport { RGBColor } from \"../drivers/Color\";\n\nexport const PinnedColors = ({\n  pinnedColors = [],\n  onColorPicked,\n}: {\n  pinnedColors: RGBColor[];\n  onColorPicked: (color: RGBColor) => void;\n}) => {\n  return (\n    <Box\n      className=\"ColorPickerHistory\"\n      direction=\"row\"\n      justify=\"start\"\n      wrap\n      gap=\"xxsmall\"\n    >\n      {pinnedColors.slice(0, 8).map((color, index) => (\n        <Box\n          key={color.toHex()}\n          height=\"xxsmall\"\n          width=\"xxsmall\"\n          pad={{ bottom: \"xsmall\" }}\n        >\n          <Button\n            fill=\"vertical\"\n            size=\"small\"\n            onClick={() => onColorPicked(color)}\n            key={index}\n            style={{\n              backgroundColor: color.toHex(),\n              border: \"none\",\n            }}\n          ></Button>\n        </Box>\n      ))}\n    </Box>\n  );\n};\n","export class HSLColor {\n  /**\n   * @param hslString A string following the possible forms\n   * hsl(180 100% 50%)\n   * hsl(180deg,100%,50%)\n   * hsl(180deg 100% 50%)\n   * hsl(3.14rad,100%,50%)\n   * hsl(3.14rad 100% 50%)\n   * hsl(0.5turn,100%,50%)\n   * hsl(0.5turn 100% 50%)\n   */\n  static fromHSLString(hslString: string) {\n    let sep = hslString.indexOf(\",\") > -1 ? \",\" : \" \";\n    const hsl = hslString.substr(4).split(\")\")[0].split(sep);\n\n    let hString = hsl[0];\n    let s = parseFloat(hsl[1].substr(0, hsl[1].length - 1)) / 100;\n    let l = parseFloat(hsl[2].substr(0, hsl[2].length - 1)) / 100;\n\n    let h = 0;\n\n    if (hString.indexOf(\"deg\") > -1)\n      hString = hString.substr(0, hString.length - 3);\n    else if (hString.indexOf(\"rad\") > -1)\n      h = Math.round(\n        parseFloat(hString.substr(0, hString.length - 3)) * (180 / Math.PI)\n      );\n    else if (hString.indexOf(\"turn\") > -1)\n      h = Math.round(parseFloat(hString.substr(0, hString.length - 4)) * 360);\n    // Keep hue fraction of 360 if ending up over\n    if (h >= 360) h %= 360;\n\n    return new HSLColor(h, s, l);\n  }\n\n  static fromRGB(r: number, g: number, b: number) {\n    // Make r, g, and b fractions of 1\n    r /= 255;\n    g /= 255;\n    b /= 255;\n\n    // Find greatest and smallest channel values\n    let cMin = Math.min(r, g, b);\n    let cMax = Math.max(r, g, b);\n    let delta = cMax - cMin;\n    let h = 0;\n    let s = 0;\n    let l = 0;\n\n    // Calculate hue\n    // No difference\n    if (delta === 0) h = 0;\n    // Red is max\n    else if (cMax === r) h = ((g - b) / delta) % 6;\n    // Green is max\n    else if (cMax === g) h = (b - r) / delta + 2;\n    // Blue is max\n    else h = (r - g) / delta + 4;\n\n    h = Math.round(h * 60);\n\n    // Make negative hues positive behind 360Â°\n    if (h < 0) h += 360;\n\n    // Calculate lightness\n    l = (cMax + cMin) / 2;\n\n    // Calculate saturation\n    s = delta === 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));\n\n    return new HSLColor(h, s, l);\n  }\n\n  constructor(hue: number, saturation: number, lightness: number) {\n    this.hsl = [hue, saturation, lightness];\n  }\n\n  hsl: [number, number, number];\n\n  get h() {\n    return this.hsl[0];\n  }\n  get s() {\n    return this.hsl[1];\n  }\n  get l() {\n    return this.hsl[2];\n  }\n\n  set h(h: number) {\n    this.hsl[0] = h;\n  }\n  set s(s: number) {\n    this.hsl[1] = s;\n  }\n  set l(l: number) {\n    this.hsl[2] = l;\n  }\n\n  toHSLString() {\n    const [h, s, l] = this.hsl;\n    return \"hsl(\" + h + \",\" + s * 100 + \"%,\" + l * 100 + \"%)\";\n  }\n\n  toRGB(): RGBColor {\n    return RGBColor.fromHSL(...this.hsl);\n  }\n\n  clone(): HSLColor {\n    return new HSLColor(...this.hsl);\n  }\n}\n\nexport type NoColor = \"NO_COLOR\";\nexport class RGBColor {\n  static readonly NO_COLOR: NoColor = \"NO_COLOR\";\n  /**\n   * @param h Degrees\n   * @param s Percent\n   * @param l Percent\n   */\n\n  static fromHSL(h: number, s: number, l: number) {\n    if (h < 0 || h > 359) {\n      throw new RangeError(\"Hue should be between 0 and 359 inclusive\");\n    }\n    if (s < 0 || s > 1) {\n      throw new RangeError(\n        \"Saturation is a percentage and should be between 0 and 1 inclusive\"\n      );\n    }\n    if (l < 0 || l > 1) {\n      throw new RangeError(\n        \"Lightness is a percentage and should be between 0 and 1 inclusive\"\n      );\n    }\n\n    let c = (1 - Math.abs(2 * l - 1)) * s;\n    let x = c * (1 - Math.abs(((h / 60) % 2) - 1));\n    let m = l - c / 2;\n    let r = 0;\n    let g = 0;\n    let b = 0;\n\n    if (0 <= h && h < 60) {\n      r = c;\n      g = x;\n      b = 0;\n    } else if (60 <= h && h < 120) {\n      r = x;\n      g = c;\n      b = 0;\n    } else if (120 <= h && h < 180) {\n      r = 0;\n      g = c;\n      b = x;\n    } else if (180 <= h && h < 240) {\n      r = 0;\n      g = x;\n      b = c;\n    } else if (240 <= h && h < 300) {\n      r = x;\n      g = 0;\n      b = c;\n    } else if (300 <= h && h < 360) {\n      r = c;\n      g = 0;\n      b = x;\n    }\n    r = Math.round((r + m) * 255);\n    g = Math.round((g + m) * 255);\n    b = Math.round((b + m) * 255);\n\n    return new RGBColor(r, g, b);\n  }\n\n  /**\n   * @param hex A number between 0-16777215\n   */\n  static fromHex(hex: number) {\n    if (!Number.isInteger(hex))\n      throw new TypeError(`Number should be an integer, got: ${hex}`);\n    if (hex < 0 || hex > (2 ^ 24)) {\n      throw new RangeError(\"Number should be between 0-16777215 inclusive\");\n    }\n\n    const hexString = hex.toString(16);\n\n    return RGBColor.fromHexString(\"#\" + hexString);\n  }\n\n  static fromRGBString(rgbString: string) {\n    let sep = rgbString.indexOf(\",\") > -1 ? \",\" : \" \";\n    const rgbChunks = rgbString.substr(4).split(\")\")[0].split(sep);\n    const rgbValues: number[] = [];\n\n    for (let R in rgbChunks) {\n      let r = rgbChunks[R];\n      if (r.indexOf(\"%\") > -1)\n        rgbValues[R] =\n          Math.round(parseFloat(r.substr(0, r.length - 1)) / 100) * 255;\n    }\n\n    const r = rgbValues[0];\n    const g = rgbValues[1];\n    const b = rgbValues[2];\n\n    return new RGBColor(r, g, b);\n  }\n\n  static fromHexString(hexString: string) {\n    if (hexString.length !== 7) {\n      throw new TypeError(\n        \"Hex string is not 7 characters long. Got: \" + hexString\n      );\n    }\n\n    if (hexString[0] !== \"#\") {\n      throw new TypeError(\n        \"Hex color string should start with #. Got: \" + hexString[0]\n      );\n    }\n\n    const r = parseInt(\"0x\" + hexString[1] + hexString[2], 16);\n    const g = parseInt(\"0x\" + hexString[3] + hexString[4], 16);\n    const b = parseInt(\"0x\" + hexString[5] + hexString[6], 16);\n\n    return new RGBColor(r, g, b);\n  }\n\n  constructor(red: number, green: number, blue: number) {\n    this.rgb = [red, green, blue];\n  }\n\n  rgb: [number, number, number];\n\n  get r() {\n    return this.rgb[0];\n  }\n  get g() {\n    return this.rgb[1];\n  }\n  get b() {\n    return this.rgb[2];\n  }\n\n  set r(r: number) {\n    this.rgb[0] = r;\n  }\n  set g(g: number) {\n    this.rgb[1] = g;\n  }\n  set b(b: number) {\n    this.rgb[2] = b;\n  }\n\n  static Equals(a: RGBColor, b: RGBColor) {\n    const [r1, g1, b1] = a.rgb;\n    const [r2, g2, b2] = b.rgb;\n\n    return r1 === r2 && g1 === g2 && b1 === b2;\n  }\n\n  toHex() {\n    const [r, g, b] = this.rgb;\n    let rString = r.toString(16);\n    let gString = g.toString(16);\n    let bString = b.toString(16);\n\n    if (rString.length === 1) rString = \"0\" + rString;\n    if (gString.length === 1) gString = \"0\" + gString;\n    if (bString.length === 1) bString = \"0\" + bString;\n\n    return \"#\" + rString + gString + bString;\n  }\n\n  toHSL(): HSLColor {\n    return HSLColor.fromRGB(...this.rgb);\n  }\n}\n","import { ColorPickerHistory } from \"./components/ColorPickerHistory\";\nimport { PinnedColors } from \"./components/PinnedColors\";\nimport { useEffect } from \"react\";\nimport { RGBColor } from \"./drivers/Color\";\nimport { AvailablePalettes } from \"./PaletteDictionary\";\n\n/** TODO: Make a component that displays a list of colors.\n * Use logic here to decide which colors to show.\n * Probably remove ColorPickerHistory and PinnedColors and combine into here */\nexport const BodyColorPicker = ({\n  setColorAndTurnOffPicker,\n  color,\n  palette,\n  pickerMode,\n  pinnedColors,\n  colorHistory,\n  setColorHistory,\n}: {\n  pickerMode: \"history\" | \"pinned\";\n  setColorHistory: (history: RGBColor[]) => void;\n  setColorAndTurnOffPicker: (color: RGBColor) => void;\n  color: RGBColor;\n  palette: AvailablePalettes;\n  pinnedColors: RGBColor[];\n  colorHistory: RGBColor[];\n}) => {\n  useEffect(() => {\n    if (\n      colorHistory.filter((currentColor) => {\n        return RGBColor.Equals(currentColor, color);\n      }).length !== 0\n    ) {\n      return;\n    }\n\n    let newColorHistory = [...colorHistory];\n    newColorHistory.unshift(color);\n    if (newColorHistory.length > 8) {\n      newColorHistory = newColorHistory.slice(0, 8);\n    }\n\n    setColorHistory(newColorHistory);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [color]);\n\n  if (pickerMode === \"history\") {\n    return (\n      <ColorPickerHistory\n        setColorHistory={setColorHistory}\n        colorHistory={colorHistory}\n        onColorPicked={setColorAndTurnOffPicker}\n        colorSelected={color}\n      />\n    );\n  } else {\n    return (\n      <PinnedColors\n        onColorPicked={setColorAndTurnOffPicker}\n        pinnedColors={pinnedColors}\n      />\n    );\n  }\n};\n","import { TouchEvent, useEffect, useRef } from \"react\";\nimport \"../styles/CanvasContainer.css\";\n\nexport const CanvasContainer = ({\n  onCanvasCreated,\n  onTouchEvent,\n  pixelDimensions,\n}: {\n  pixelDimensions: number;\n  onCanvasCreated: (canvas: HTMLCanvasElement) => void;\n  onTouchEvent: (\n    canvas: HTMLCanvasElement,\n    touchEvent: TouchEvent<HTMLCanvasElement>\n  ) => void;\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (canvas) {\n      onCanvasCreated(canvas);\n    }\n  }, [onCanvasCreated]);\n\n  const onInnerTouchEvent = (event: TouchEvent<HTMLCanvasElement>) => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    onTouchEvent(canvas, event);\n  };\n\n  return (\n    <canvas\n      className=\"CanvasContainer\"\n      style={{\n        backgroundSize: `${100 / pixelDimensions / 2}%`,\n      }}\n      ref={canvasRef}\n      width={pixelDimensions}\n      height={pixelDimensions}\n      onTouchEnd={onInnerTouchEvent}\n      onTouchMove={onInnerTouchEvent}\n    />\n  );\n};\n","import { useEffect, useRef } from \"react\";\nimport \"../styles/Grid.css\";\n\nexport const Grid = ({\n  pixelDimensions,\n  rootCanvas,\n}: {\n  pixelDimensions: number;\n  rootCanvas: HTMLCanvasElement;\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const context = canvas?.getContext(\"2d\");\n\n    if (!context || !canvas) return;\n\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    context.strokeStyle = \"lightgrey\";\n    context.lineWidth = 1;\n    const xIncrement = canvas.width / pixelDimensions;\n    for (let xIndex = 0; xIndex < pixelDimensions; xIndex++) {\n      context.moveTo(Math.round(xIndex * xIncrement), 0);\n      context.lineTo(Math.round(xIndex * xIncrement), canvas.height);\n      context.stroke();\n    }\n\n    // Horizontal lines\n    const yIncrement = canvas.height / pixelDimensions;\n    for (let yIndex = 0; yIndex < pixelDimensions; yIndex++) {\n      context.moveTo(0, Math.round(yIndex * yIncrement));\n      context.lineTo(canvas.width, Math.round(yIndex * yIncrement));\n      context.stroke();\n    }\n\n    return () => {\n      context.clearRect(0, 0, canvas.width, canvas.height);\n    };\n  });\n  return (\n    <canvas\n      ref={canvasRef}\n      key={pixelDimensions}\n      className=\"Grid\"\n      width={rootCanvas.clientWidth}\n      height={rootCanvas.clientHeight}\n    />\n  );\n};\n","import { Stack, StackProps } from \"grommet\";\nimport { useState } from \"react\";\nimport { CanvasContainer } from \"./components/CanvasContainer\";\nimport { ValidDimensions } from \"./components/DimensionPicker\";\nimport { Grid } from \"./components/Grid\";\nexport const CanvasStack = ({\n  isGridShown,\n  pixelDimensions,\n  onCanvasCreated,\n  onCanvasTouch,\n  stackProps,\n}: {\n  isPaletteMenuShown: boolean;\n  isGridShown: boolean;\n  pixelDimensions: ValidDimensions;\n  onCanvasCreated: (canvas: HTMLCanvasElement) => void;\n  onCanvasTouch: (\n    canvas: HTMLCanvasElement,\n    event: React.TouchEvent<HTMLCanvasElement>\n  ) => void;\n  stackProps: StackProps;\n}) => {\n  const [canvas, setCanvas] = useState<HTMLCanvasElement>();\n  return (\n    <Stack {...stackProps}>\n      <CanvasContainer\n        onCanvasCreated={(canvas) => {\n          setCanvas(canvas);\n          onCanvasCreated(canvas);\n        }}\n        pixelDimensions={pixelDimensions}\n        onTouchEvent={onCanvasTouch}\n      />\n\n      {canvas && isGridShown && (\n        <Grid pixelDimensions={pixelDimensions} rootCanvas={canvas} />\n      )}\n    </Stack>\n  );\n};\n","import { Box, Button, Layer, Text } from \"grommet\";\nimport { Close } from \"grommet-icons\";\nimport { PropsWithChildren } from \"react\";\n\nexport const Modal = ({\n  onClose,\n  children,\n  heading,\n}: PropsWithChildren<{ onClose: () => void; heading: string }>) => {\n  return (\n    <Layer modal full=\"horizontal\" onClickOutside={onClose}>\n      <Box pad=\"small\" fill>\n        <Box direction=\"row\" fill={\"horizontal\"} justify=\"between\">\n          <Box justify=\"center\">\n            <Text>{heading}</Text>\n          </Box>\n          <Box direction=\"row\" justify=\"end\">\n            <Button icon={<Close />} onClick={() => onClose()}></Button>\n          </Box>\n        </Box>\n        <Box>{children}</Box>\n      </Box>\n    </Layer>\n  );\n};\n","import { Box, Button, Text } from \"grommet\";\nimport React from \"react\";\nimport { Modal } from \"./Modal\";\n\nexport type ConfirmModalProps = {\n  onAccept: () => void;\n  onCancel?: () => void;\n  onClose: () => void;\n  message?: string;\n  acceptButtonText?: string;\n  cancelButtonText?: string;\n};\n\nexport const ConfirmModal = ({\n  onAccept,\n  onCancel,\n  onClose,\n  message = \"Are you sure?\",\n  cancelButtonText = \"Cancel\",\n  acceptButtonText = \"Accept\",\n}: ConfirmModalProps) => {\n  return (\n    <Modal onClose={onClose} heading={\"Confirm?\"}>\n      <Text alignSelf=\"center\">{message}</Text>\n      <Box direction=\"row\" justify=\"between\" gap=\"small\">\n        <Button label={cancelButtonText} onClick={onCancel} alignSelf=\"start\" />\n        <Button\n          primary\n          label={acceptButtonText}\n          onClick={onAccept}\n          alignSelf=\"end\"\n        />\n      </Box>\n    </Modal>\n  );\n};\n","import { NoColor, RGBColor } from \"./Color\";\nimport { getRelativeClickPosition } from \"./getRelativeClickPosition\";\n\nexport class KeyPairMap<KeyA, KeyB, Value> implements Map<[KeyA, KeyB], Value> {\n  constructor(keyPairMap?: KeyPairMap<KeyA, KeyB, Value>) {\n    if (!keyPairMap) return;\n\n    for (let [[keyA, keyB], value] of keyPairMap) {\n      this.set([keyA, keyB], value);\n    }\n  }\n\n  private map = new Map<KeyA, Map<KeyB, Value>>();\n\n  clear(): void {\n    this.map.clear();\n  }\n\n  delete([keyA, keyB]: [KeyA, KeyB]): boolean {\n    return this.map.get(keyA)?.delete(keyB) || false;\n  }\n\n  clone(): KeyPairMap<KeyA, KeyB, Value> {\n    return new KeyPairMap(this);\n  }\n\n  forEach(\n    callbackfn: (\n      value: Value,\n      key: [KeyA, KeyB],\n      map: Map<[KeyA, KeyB], Value>\n    ) => void,\n    thisArg?: any\n  ): void {\n    const refMap = this.toRefMap();\n\n    refMap.forEach(callbackfn, thisArg);\n  }\n\n  private toRefMap() {\n    const tempMap = new Map<[KeyA, KeyB], Value>();\n    this.map.forEach((innerMap, keyA, outerMap) => {\n      innerMap.forEach((value, keyB, innerMap) => {\n        const keys = [keyA, keyB] as [KeyA, KeyB];\n        tempMap.set(keys, value);\n      });\n    });\n    return tempMap;\n  }\n\n  get([keyA, keyB]: [KeyA, KeyB]): Value | undefined {\n    return this.map.get(keyA)?.get(keyB);\n  }\n\n  has([keyA, keyB]: [KeyA, KeyB]): boolean {\n    return this.map.get(keyA)?.has(keyB) || false;\n  }\n\n  set([keyA, keyB]: [KeyA, KeyB], value: Value): this {\n    const hasKeyA = this.map.has(keyA);\n\n    if (!hasKeyA) {\n      this.map.set(keyA, new Map());\n    }\n    this.map.get(keyA)!.set(keyB, value);\n\n    return this;\n  }\n\n  get size() {\n    return this.toRefMap().size;\n  }\n\n  [Symbol.iterator](): IterableIterator<[[KeyA, KeyB], Value]> {\n    return this.toRefMap()[Symbol.iterator]();\n  }\n\n  entries(): IterableIterator<[[KeyA, KeyB], Value]> {\n    return this.toRefMap().entries();\n  }\n\n  keys(): IterableIterator<[KeyA, KeyB]> {\n    return this.toRefMap().keys();\n  }\n\n  values(): IterableIterator<Value> {\n    return this.toRefMap().values();\n  }\n\n  toString(): string {\n    let lines = [];\n\n    for (let [key, value] of this) {\n      lines.push(`${key[0]}, ${key[1]}, ${value}`);\n    }\n\n    return lines.join(\"\\n\");\n  }\n  [Symbol.toStringTag]: string;\n}\n\nexport class PaintCanvas {\n  static DrawToCanvas(paintCanvas: PaintCanvas, canvas: HTMLCanvasElement) {\n    const context = canvas.getContext(\"2d\");\n    if (!context) throw new Error(\"Could not get context for canvas\");\n    paintCanvas.forEach(([x, y], color) => {\n      if (color === RGBColor.NO_COLOR) {\n        context.clearRect(x, y, 1, 1);\n        return;\n      }\n\n      context.fillStyle = color.toHex();\n      context.fillRect(x, y, 1, 1);\n    });\n  }\n\n  static AreDimensionsCompatible(\n    paintCanvas: PaintCanvas,\n    canvas: HTMLCanvasElement\n  ) {\n    const { width, height } = canvas;\n    const dimension = paintCanvas.dimension();\n\n    if (width !== height) {\n      return false;\n    }\n\n    if (dimension !== width) {\n      return false;\n    }\n\n    return true;\n  }\n\n  drawToCanvas() {\n    if (this.canvas === undefined) {\n      throw new Error(\"Cannot draw to canvas, no canvas set\");\n    }\n\n    PaintCanvas.DrawToCanvas(this, this.canvas);\n  }\n\n  tryDrawToCanvas(): boolean {\n    try {\n      this.drawToCanvas();\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  setCanvas(canvas: HTMLCanvasElement) {\n    if (!PaintCanvas.AreDimensionsCompatible(this, canvas)) {\n      throw new RangeError(\n        `PaintCanvas and HTMLCanvas should be square and the same dimensions. Got PaintCanvas: ${this.dimension()} canvas: ${\n          canvas.width\n        }x${canvas.height}`\n      );\n    }\n\n    this.canvas = canvas;\n  }\n\n  hasCanvas(): boolean {\n    return this.canvas !== undefined;\n  }\n\n  getCanvas(): HTMLCanvasElement | undefined {\n    return this.canvas;\n  }\n\n  private pixelMap = new KeyPairMap<number, number, RGBColor | NoColor>();\n\n  getPixelMap() {\n    return this.pixelMap;\n  }\n\n  setPixelMap(map: KeyPairMap<number, number, RGBColor | \"NO_COLOR\">) {\n    if (map.size !== this.pixelMap.size) {\n      throw new RangeError(\n        \"Cannot set pixel map. Pixel maps are not the same dimensions\"\n      );\n    }\n    this.pixelMap = map.clone();\n  }\n\n  setPixelsFromImage(image: HTMLImageElement) {\n    const canvas = document.createElement(\"canvas\");\n    const context = canvas.getContext(\"2d\");\n    if (!context) throw new Error(\"Could not get context for canvas\");\n\n    canvas.width = image.naturalWidth;\n    canvas.height = image.naturalHeight;\n    context.drawImage(image, 0, 0);\n\n    this.setPixelsFromCanvas(canvas);\n  }\n\n  setPixelsFromCanvas(canvas: HTMLCanvasElement) {\n    const context = canvas.getContext(\"2d\");\n    if (!context) throw new Error(\"Could not get context for canvas\");\n\n    const xIntervals = canvas.width / this.dimension();\n    const yIntervals = canvas.height / this.dimension();\n    this.mutableMap(([x, y]) => {\n      const { data } = context.getImageData(\n        x * xIntervals,\n        y * yIntervals,\n        1,\n        1\n      );\n\n      const [r, g, b, a] = data;\n      const color = a === 0 ? RGBColor.NO_COLOR : new RGBColor(r, g, b);\n      return color;\n    });\n  }\n\n  clear() {\n    this.mutableMap(() => RGBColor.NO_COLOR);\n  }\n\n  setColorAt(x: number, y: number, color: RGBColor | NoColor) {\n    const isPixelInRange = this.pixelMap.has([x, y]);\n\n    if (!isPixelInRange) {\n      throw RangeError(`Pixel at ${x},${y} does not exist`);\n    }\n\n    this.pixelMap.set([x, y], color);\n  }\n\n  getColorAt(x: number, y: number): RGBColor | NoColor {\n    const maybeColor = this.pixelMap.get([x, y]);\n\n    if (maybeColor === undefined)\n      throw RangeError(`Pixel at ${x},${y} does not exist`);\n\n    return maybeColor;\n  }\n\n  map<T>(\n    callbackfn: (coord: [x: number, y: number], color: RGBColor | NoColor) => T\n  ): T[] {\n    const results = new Array<T>();\n    for (let [key, value] of this.pixelMap.entries()) {\n      const elementResult = callbackfn(key, value);\n      results.push(elementResult);\n    }\n\n    return results;\n  }\n\n  mutableMap(\n    callbackfn: (\n      coord: [x: number, y: number],\n      color: RGBColor | NoColor\n    ) => RGBColor | NoColor\n  ) {\n    for (let [key, value] of this.pixelMap.entries()) {\n      const result = callbackfn(key, value);\n      this.pixelMap.set(key, result);\n    }\n  }\n\n  forEach(\n    callbackfn: (\n      coord: [x: number, y: number],\n      color: RGBColor | NoColor\n    ) => void\n  ) {\n    for (let [key, value] of this.pixelMap.entries()) {\n      callbackfn(key, value);\n    }\n  }\n  private canvas?: HTMLCanvasElement;\n\n  constructor(dimension: number) {\n    for (let x = 0; x < dimension; x++) {\n      for (let y = 0; y < dimension; y++) {\n        const keys = [x, y] as [number, number];\n        const color = RGBColor.NO_COLOR;\n        this.pixelMap.set(keys, color);\n      }\n    }\n  }\n\n  dimension(): number {\n    return Math.sqrt(this.pixelMap.size);\n  }\n\n  touchEvent(event: React.TouchEvent<HTMLElement>, color: RGBColor | NoColor) {\n    const { quantX, quantY } = this.touchToCoords(event);\n\n    const currentColor = this.getColorAt(quantX, quantY);\n\n    if (color === \"NO_COLOR\" && currentColor === \"NO_COLOR\") {\n      return;\n    }\n\n    if (color === \"NO_COLOR\" && currentColor !== \"NO_COLOR\") {\n      this.setColorAt(quantX, quantY, color);\n      return;\n    }\n\n    if (color !== \"NO_COLOR\" && currentColor === \"NO_COLOR\") {\n      this.setColorAt(quantX, quantY, color);\n      return;\n    }\n\n    if (color !== \"NO_COLOR\" && currentColor !== \"NO_COLOR\") {\n      if (!RGBColor.Equals(color, currentColor)) {\n        this.setColorAt(quantX, quantY, color);\n      }\n    }\n  }\n\n  touchToCoords(event: React.TouchEvent<HTMLElement>) {\n    const { relativeX, relativeY } = getRelativeClickPosition(event);\n    const scaledX = relativeX * this.dimension();\n    const scaledY = relativeY * this.dimension();\n    const quantX = Math.floor(scaledX);\n    const quantY = Math.floor(scaledY);\n    return { quantX, quantY };\n  }\n}\nexport class UndoablePaintCanvas extends PaintCanvas {\n  static AreColorsEqual = (\n    colorA: RGBColor | NoColor,\n    colorB: RGBColor | NoColor\n  ) => {\n    if (colorA === \"NO_COLOR\" && colorB === \"NO_COLOR\") {\n      return true;\n    }\n\n    if (colorA === \"NO_COLOR\" && colorB !== \"NO_COLOR\") {\n      return false;\n    }\n\n    if (colorA !== \"NO_COLOR\" && colorB === \"NO_COLOR\") {\n      return false;\n    }\n\n    if (colorA !== \"NO_COLOR\" && colorB !== \"NO_COLOR\") {\n      if (RGBColor.Equals(colorA, colorB)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  undoBuffer: UndoRedoBuffer<KeyPairMap<number, number, RGBColor | \"NO_COLOR\">>;\n  constructor(dimension: number) {\n    super(dimension);\n\n    this.undoBuffer = new UndoRedoBuffer<\n      KeyPairMap<number, number, RGBColor | NoColor>\n    >(this.getPixelMap().clone());\n  }\n\n  mutableMap(\n    callbackfn: (\n      coord: [x: number, y: number],\n      color: RGBColor | NoColor\n    ) => RGBColor | NoColor\n  ) {\n    super.mutableMap(callbackfn);\n    this.undoBuffer.addCurrent(this.getPixelMap().clone());\n  }\n\n  setColorAt(x: number, y: number, color: RGBColor | NoColor) {\n    super.setColorAt(x, y, color);\n    this.undoBuffer.addCurrent(this.getPixelMap().clone());\n  }\n\n  undo() {\n    const undo = this.undoBuffer.undo();\n    this.setPixelMap(undo);\n  }\n\n  redo() {\n    const redo = this.undoBuffer.redoOne();\n    if (redo !== undefined) {\n      this.setPixelMap(redo);\n    }\n  }\n\n  fillWithColor(x: number, y: number, fillColor: RGBColor | NoColor) {\n    const startColor = this.getColorAt(x, y);\n\n    const visited = new KeyPairMap<number, number, boolean>();\n    this.getPixelMap()\n      .clone()\n      .forEach((color, [x, y]) => {\n        visited.set([x, y], false);\n      });\n\n    this.floodFill(x, y, fillColor, startColor, visited);\n    this.undoBuffer.addCurrent(this.getPixelMap().clone());\n  }\n\n  private floodFill(\n    x: number,\n    y: number,\n    fillColor: RGBColor | NoColor,\n    startColor: RGBColor | NoColor,\n    visited: KeyPairMap<number, number, boolean>\n  ) {\n    if (!this.cellExists(x, y)) return;\n    if (visited.get([x, y]) === true) return;\n\n    const cellColor = this.getColorAt(x, y);\n    if (!UndoablePaintCanvas.AreColorsEqual(cellColor, startColor)) return;\n\n    super.setColorAt(x, y, fillColor);\n    visited.set([x, y], true);\n\n    if (visited.get([x, y + 1]) === false)\n      this.floodFill(x, y + 1, fillColor, startColor, visited);\n\n    if (visited.get([x, y - 1]) === false)\n      this.floodFill(x, y - 1, fillColor, startColor, visited);\n\n    if (visited.get([x + 1, y]) === false)\n      this.floodFill(x + 1, y, fillColor, startColor, visited);\n\n    if (visited.get([x - 1, y]) === false)\n      this.floodFill(x - 1, y, fillColor, startColor, visited);\n  }\n\n  private cellExists = (x: number, y: number) => this.getPixelMap().has([x, y]);\n}\n\nexport class UndoBuffer<T> {\n  buffer: T[];\n\n  constructor(private base: T, private maxSize?: number) {\n    this.buffer = [base];\n  }\n\n  top() {\n    return this.buffer[this.buffer.length - 1] as T | undefined;\n  }\n\n  undo() {\n    this.buffer.pop();\n    const maybeReverseState = this.buffer[this.buffer.length - 1] as\n      | T\n      | undefined;\n    if (maybeReverseState) {\n      return maybeReverseState;\n    } else {\n      this.buffer = [this.base];\n      return this.base;\n    }\n  }\n\n  addCurrent(value: T) {\n    this.buffer.push(value);\n\n    if (this.maxSize && this.maxSize < this.buffer.length) {\n      this.buffer = this.buffer.slice(-this.maxSize - 2);\n    }\n  }\n\n  getUndoSize() {\n    return Math.max(this.buffer.length - 2, 0);\n  }\n\n  getBufferLength() {\n    return this.buffer.length;\n  }\n\n  clear() {\n    this.buffer = [];\n  }\n}\n\nexport class UndoRedoBuffer<T> extends UndoBuffer<T> {\n  private redoBuffer = new Array<T>();\n\n  undo(): T {\n    const maybeTop = this.top();\n    if (maybeTop !== undefined && this.getBufferLength() > 1) {\n      this.redoBuffer.push(maybeTop);\n    }\n\n    const previousPoint = super.undo();\n    return previousPoint;\n  }\n\n  addCurrent(value: T) {\n    this.redoBuffer = [];\n    super.addCurrent(value);\n  }\n\n  getUndoSize() {\n    return super.getUndoSize();\n  }\n\n  getRedoSize() {\n    return this.redoBuffer.length;\n  }\n\n  redoOne(): T | undefined {\n    const redid = this.redoBuffer.pop();\n    if (redid !== undefined) {\n      super.addCurrent(redid);\n    }\n\n    return redid;\n  }\n\n  clear() {\n    this.redoBuffer = [];\n    super.clear();\n  }\n}\n","import { TouchEvent } from \"react\";\n\nexport function getRelativeClickPosition(\n  event: TouchEvent<HTMLElement>\n): { relativeX: number; relativeY: number } {\n  const screenX = event.changedTouches[0].clientX;\n  const screenY = event.changedTouches[0].clientY;\n  const rect = (event.target as HTMLElement).getBoundingClientRect();\n\n  const clip = (value: number, min: number, max: number) =>\n    Math.min(max, Math.max(value, min));\n\n  const clippedX = clip(screenX - rect.left, 0, rect.width - 1);\n  const clippedY = clip(screenY - rect.top, 0, rect.height - 1);\n\n  const relativeX = clippedX / rect.width;\n  const relativeY = clippedY / rect.height;\n  return { relativeX: relativeX, relativeY: relativeY };\n}\n","/* eslint-disable jsx-a11y/anchor-has-content */\nimport { Button } from \"grommet\";\nimport { Share } from \"grommet-icons\";\nimport { useRef } from \"react\";\n\nexport const SaveButton = ({ canvas }: { canvas: HTMLCanvasElement }) => {\n  const anchorRef = useRef<HTMLAnchorElement>(null);\n  const onShareClick = async (event: React.MouseEvent<HTMLButtonElement>) => {\n    const fullScaleCanvas = drawToHigherResolutionCanvas(canvas);\n\n    try {\n      const blob = await new Promise<Blob>((resolve, reject) => {\n        fullScaleCanvas.toBlob((maybeBlob) => {\n          if (maybeBlob) {\n            resolve(maybeBlob);\n          } else {\n            reject(new Error(\"Unable to convert canvas to blob\"));\n          }\n        }, \"image/png\");\n      });\n\n      if (document.location.protocol !== \"https:\") {\n        throw new Error(\"Could not share. Page is not HTTPS.\");\n      }\n\n      if (navigator.share === undefined) {\n        throw new Error(\"Share unsupported in this browser\");\n      }\n\n      const files = Object.freeze([\n        new File([blob], \"my-pixel-art.png\", { type: blob.type }),\n      ]);\n\n      if (!(navigator.canShare && navigator.canShare({ files }))) {\n        throw new Error(\"File sharing unsupported in this browser\");\n      }\n\n      await navigator\n        .share({\n          title: \"My pixel art\",\n          files,\n        })\n        .catch((error: Error) => {\n          if (error.name === \"AbortError\") {\n            console.debug(\"User cancelled share\");\n            return;\n          }\n          throw error;\n        });\n    } catch (error) {\n      console.debug(\"Could not use share api, using image download\");\n      console.debug(error);\n      const image = fullScaleCanvas.toDataURL(\"image/png\");\n      if (anchorRef.current) {\n        anchorRef.current.href = image;\n        anchorRef.current.click();\n      }\n    }\n  };\n  return (\n    <>\n      <Button icon={<Share />} onClick={onShareClick} />\n      <a\n        ref={anchorRef}\n        href=\"/\"\n        style={{ display: \"none\" }}\n        download=\"my-pixel-art.png\"\n      />\n    </>\n  );\n};\n\nfunction drawToHigherResolutionCanvas(canvas: HTMLCanvasElement) {\n  const fullScaleCanvas = document.createElement(\"canvas\");\n  fullScaleCanvas.width = 1024;\n  fullScaleCanvas.height = 1024;\n  const context = fullScaleCanvas.getContext(\"2d\")!;\n  context.imageSmoothingEnabled = false;\n  context.drawImage(\n    canvas,\n    0,\n    0,\n    fullScaleCanvas.width,\n    fullScaleCanvas.height\n  );\n  return fullScaleCanvas;\n}\n","import { Box, Grid, Button } from \"grommet\";\nimport { Actions, Add } from \"grommet-icons\";\nimport { SaveButton } from \"./components/SaveButton\";\nexport const Footer = ({\n  canvas,\n  onAddButtonClicked,\n  setSettingsMenuShown,\n  gridArea,\n}: {\n  canvas: HTMLCanvasElement;\n  onAddButtonClicked: () => void;\n  setSettingsMenuShown: (value: boolean) => void;\n} & { gridArea: string }) => {\n  return (\n    <Box gridArea={gridArea} pad={{ left: \"small\", right: \"small\" }}>\n      <Grid\n        columns={{\n          count: 3,\n          size: [\"auto\", \"auto\", \"auto\"],\n        }}\n        fill\n        gap=\"small\"\n      >\n        <Box align=\"start\">\n          <Button\n            icon={<Actions />}\n            onClick={() => setSettingsMenuShown(true)}\n          />\n        </Box>\n        <Box align=\"center\">\n          <Button icon={<Add />} onClick={onAddButtonClicked} />\n        </Box>\n        <Box align=\"end\">{<SaveButton canvas={canvas} />}</Box>\n      </Grid>\n    </Box>\n  );\n};\n","import { Select } from \"grommet\";\nimport { ReactElement } from \"react\";\n\nconst validDimensions = [\n  { value: 1, label: \"1x1\" },\n  { value: 8, label: \"8x8\" },\n  { value: 10, label: \"10x10\" },\n  { value: 12, label: \"12x12\" },\n  { value: 14, label: \"14x14\" },\n  { value: 16, label: \"16x16\" },\n  { value: 18, label: \"18x18\" },\n  { value: 20, label: \"20x20\" },\n  { value: 22, label: \"22x22\" },\n  { value: 24, label: \"24x24\" },\n] as const;\n\nconst labelToValue = {\n  \"1x1\": 1,\n  \"8x8\": 8,\n  \"10x10\": 10,\n  \"12x12\": 12,\n  \"14x14\": 14,\n  \"16x16\": 16,\n  \"18x18\": 18,\n  \"20x20\": 20,\n  \"22x22\": 22,\n  \"24x24\": 24,\n} as const;\n\nconst valueToLabel = {\n  1: \"1x1\",\n  8: \"8x8\",\n  10: \"10x10\",\n  12: \"12x12\",\n  14: \"14x14\",\n  16: \"16x16\",\n  18: \"18x18\",\n  20: \"20x20\",\n  22: \"22x22\",\n  24: \"24x24\",\n} as const;\n\nconst options = [\n  \"1x1\",\n  \"8x8\",\n  \"10x10\",\n  \"12x12\",\n  \"14x14\",\n  \"16x16\",\n  \"18x18\",\n  \"20x20\",\n  \"22x22\",\n  \"24x24\",\n];\n\nexport type ValidDimensions = typeof validDimensions[number][\"value\"];\n\nexport const DimensionPicker = ({\n  dimension,\n  onDimensionChange,\n}: {\n  dimension: ValidDimensions;\n  onDimensionChange: (dimension: ValidDimensions) => void;\n}): ReactElement => {\n  return (\n    <Select\n      name=\"Select Dimensions\"\n      placeholder=\"8x8\"\n      value={valueToLabel[dimension]}\n      options={options}\n      onChange={({ option }: { option: keyof typeof labelToValue }) =>\n        onDimensionChange(labelToValue[option])\n      }\n    />\n  );\n};\n","import { Box, Button, Text } from \"grommet\";\nimport { useRef, useState } from \"react\";\n\nexport const LoadButton = ({\n  setLoadedImage,\n}: {\n  setLoadedImage: (image: HTMLImageElement) => void;\n}) => {\n  const ref = useRef<HTMLInputElement>(null);\n  const [imageName, setImageName] = useState(\"No File Chosen\");\n  return (\n    <Box direction=\"row\" gap=\"small\">\n      <Button\n        label=\"Choose File\"\n        onClick={() => {\n          const input = ref.current;\n          if (!input) return;\n          input.click();\n        }}\n      />\n      <Text\n        alignSelf=\"center\"\n        onClick={() => {\n          const input = ref.current;\n          if (!input) return;\n          input.click();\n        }}\n      >\n        {imageName}\n      </Text>\n      <input\n        ref={ref}\n        style={{ display: \"none\" }}\n        onChange={async (event) => {\n          const imagePromise = new Promise<HTMLImageElement>(\n            (resolve, reject) => {\n              if (!event.target.files || !event.target.files[0]) return;\n              const imageUrl = URL.createObjectURL(event.target.files![0]);\n              const image = new Image();\n              image.src = imageUrl;\n              image.onload = () => resolve(image);\n            }\n          );\n          const image = await imagePromise;\n          setImageName(event.target.files?.[0]?.name || \"No File Chosen\");\n          setLoadedImage(image);\n        }}\n        type=\"file\"\n        accept=\"image/*\"\n      />\n    </Box>\n  );\n};\n","import { Box, Button, Grid, Text } from \"grommet\";\nimport React, { useEffect, useState } from \"react\";\nimport { DimensionPicker, ValidDimensions } from \"./components/DimensionPicker\";\nimport { LoadButton } from \"./components/LoadButton\";\nimport { Modal } from \"./Modal\";\n\nexport const NewPageModal = ({\n  currentDimension,\n  onCancel,\n  onCreateNew,\n}: {\n  currentDimension: ValidDimensions;\n  onCancel: () => void;\n  onCreateNew: (\n    dimension: ValidDimensions,\n    loadedImage?: HTMLImageElement\n  ) => void;\n}) => {\n  const [loadedImage, setLoadedImage] = useState<HTMLImageElement>();\n  const [dimension, setDimension] = useState<ValidDimensions>(currentDimension);\n\n  useEffect(() => {\n    setDimension(currentDimension);\n  }, [currentDimension]);\n\n  return (\n    <Modal onClose={onCancel} heading=\"New Drawing\">\n      <Box pad={{ top: \"small\", bottom: \"small\" }} gap=\"small\">\n        <Text>Canvas Dimensions</Text>\n        <DimensionPicker\n          onDimensionChange={setDimension}\n          dimension={dimension}\n        />\n      </Box>\n      <Box pad={{ top: \"small\", bottom: \"small\" }} gap=\"small\">\n        <Text>Upload Image (optional)</Text>\n        <LoadButton setLoadedImage={setLoadedImage} />\n      </Box>\n\n      <Grid\n        columns={{ count: 2, size: [\"auto\", \"auto\"] }}\n        gap=\"small\"\n        pad={{ top: \"medium\", bottom: \"small\" }}\n      >\n        <Button label=\"Cancel\" onClick={onCancel} />\n\n        <Button\n          primary\n          label=\"Create New\"\n          onClick={() => onCreateNew(dimension, loadedImage)}\n        />\n      </Grid>\n    </Modal>\n  );\n};\n","export const paletteColorDictionary: {\n  [key: string]: string[];\n} = {\n  c64: [\n    \"#000000\",\n    \"#FFFFFF\",\n    \"#880000\",\n    \"#AAFFEE\",\n    \"#DD8855\",\n    \"#664400\",\n    \"#FF7777\",\n    \"#333333\",\n    \"#CC44CC\",\n    \"#00CC55\",\n    \"#0000AA\",\n    \"#EEEE77\",\n    \"#777777\",\n    \"#AAFF66\",\n    \"#0088FF\",\n    \"#BBBBBB\",\n  ],\n  cga: [\n    \"#000000\",\n    \"#0000AA\",\n    \"#00AA00\",\n    \"#00AAAA\",\n    \"#555555\",\n    \"#5555FF\",\n    \"#55FF55\",\n    \"#55FFFF\",\n    \"#AA0000\",\n    \"#AA00AA\",\n    \"#AA5500\",\n    \"#AAAAAA\",\n    \"#FF5555\",\n    \"#FF55FF\",\n    \"#FFFF55\",\n    \"#FFFFFF\",\n  ],\n  teletext: [\n    \"#000000\",\n    \"#ff0000\",\n    \"#ffff00\",\n    \"#00ff00\",\n    \"#00ffff\",\n    \"#0000ff\",\n    \"#ff00ff\",\n    \"#ffffff\",\n  ],\n};\n\nexport const paletteNameDictionary = {\n  c64: \"Commodore 64\",\n  cga: \"DOS CGA/ EGA\",\n  teletext: \"Teletext\",\n} as const;\n\nexport type AvailablePalettes = keyof typeof paletteNameDictionary;\n","import { Select } from \"grommet\";\nimport { ReactElement } from \"react\";\nimport { AvailablePalettes, paletteNameDictionary } from \"./PaletteDictionary\";\n\nconst options = [\"Commodore 64\", \"DOS CGA/ EGA\", \"Teletext\"];\n\nconst labelToValue = {\n  \"Commodore 64\": \"c64\",\n  \"DOS CGA/ EGA\": \"cga\",\n  Teletext: \"teletext\",\n} as const;\n\nexport const PalettePicker = ({\n  palette,\n  onPaletteChange,\n}: {\n  palette: AvailablePalettes;\n  onPaletteChange: (palette: AvailablePalettes) => void;\n}): ReactElement => {\n  const possiblePalettes = paletteNameDictionary;\n  return (\n    <Select\n      name=\"Select Palette\"\n      placeholder={possiblePalettes.c64}\n      value={paletteNameDictionary[palette]}\n      options={options}\n      onChange={({ option }: { option: keyof typeof labelToValue }) =>\n        onPaletteChange(labelToValue[option])\n      }\n    />\n  );\n};\n","import { Box, Button } from \"grommet\";\nimport { Pin } from \"grommet-icons\";\nimport { RGBColor } from \"./drivers/Color\";\nimport { useLongPress } from \"./drivers/useLongPress\";\nimport { Modal } from \"./Modal\";\nimport { AvailablePalettes, paletteColorDictionary } from \"./PaletteDictionary\";\nimport { PalettePicker } from \"./PalettePicker\";\nexport const PaletteModal = ({\n  onCancel,\n  setColor,\n  palette,\n  pinnedColors,\n  setPinnedColors,\n  setPalette,\n}: {\n  onCancel: () => void;\n  setColor: (color: RGBColor) => void;\n  palette: AvailablePalettes;\n  pinnedColors: RGBColor[];\n  setPalette: (palette: AvailablePalettes) => void;\n  setPinnedColors: (colors: RGBColor[]) => void;\n}) => {\n  const paletteColors = paletteColorDictionary[palette];\n  const selectedPalette = paletteColors.map(RGBColor.fromHexString);\n\n  const { onPressDown, onPressUp } = useLongPress(\n    (event) => {\n      const index = getButtonIndex(event);\n      if (index === undefined) return;\n\n      const color = selectedPalette[index];\n\n      const isPinned = !!pinnedColors.find((pinned) =>\n        RGBColor.Equals(pinned, color)\n      );\n\n      if (isPinned) {\n        const currentPinnedColors = [...pinnedColors].filter(\n          (pinned) => !RGBColor.Equals(color, pinned)\n        );\n        setPinnedColors(currentPinnedColors);\n      } else {\n        const currentPinnedColors = [...pinnedColors];\n        currentPinnedColors.push(color);\n        setPinnedColors(currentPinnedColors);\n      }\n    },\n    500,\n    (event) => {\n      if (event === undefined) return;\n\n      const maybeIndex = getButtonIndex(event);\n      if (maybeIndex === undefined) return;\n\n      const color = selectedPalette[maybeIndex];\n      setColor(color);\n      onCancel();\n    }\n  );\n  return (\n    <Modal onClose={onCancel} heading={\"Palette\"}>\n      <Box fill pad={{ top: \"small\", bottom: \"small\" }} gap=\"small\">\n        <Box\n          direction=\"row\"\n          wrap\n          justify=\"between\"\n          alignSelf=\"center\"\n          onTouchStart={onPressDown}\n          onTouchEnd={onPressUp}\n        >\n          {Object.values(selectedPalette).map((color, index) => {\n            const isPinned = !!pinnedColors.find((pinned) =>\n              RGBColor.Equals(pinned, color)\n            );\n            return (\n              <Box\n                key={index}\n                height=\"xsmall\"\n                width=\"xsmall\"\n                pad={{ bottom: \"xsmall\" }}\n              >\n                <Button\n                  primary\n                  fill=\"vertical\"\n                  size=\"large\"\n                  onClick={() => setColor(color)}\n                  key={index}\n                  data-index={index}\n                  color={color.toHex()}\n                  icon={isPinned ? <Pin /> : undefined}\n                  style={{\n                    borderRadius: \"0\",\n                    border: \"none\",\n                  }}\n                ></Button>\n              </Box>\n            );\n          })}\n        </Box>\n      </Box>\n      <Box pad={{ top: \"small\", bottom: \"small\" }} gap=\"small\">\n        <PalettePicker palette={palette} onPaletteChange={setPalette} />\n      </Box>\n    </Modal>\n  );\n};\nfunction getButtonIndex(event: React.TouchEvent): number | undefined {\n  const maybeIndexString = (event.target as HTMLButtonElement).dataset.index;\n  if (!maybeIndexString) return undefined;\n\n  return parseInt(maybeIndexString, 10);\n}\n","import { useRef } from \"react\";\n\nexport const useLongPress = (\n  onLongPressComplete: (event: React.TouchEvent<HTMLDivElement>) => void,\n  duration: number,\n  onLongPressCancel?: (\n    event: React.TouchEvent<HTMLDivElement> | undefined\n  ) => void\n) => {\n  const timeout = useRef<NodeJS.Timeout>();\n  const wasLongPress = useRef(false);\n\n  const cancelTimeout = () => {\n    timeout.current && clearTimeout(timeout.current);\n    timeout.current = undefined;\n  };\n\n  const onPressDown = (event: React.TouchEvent<HTMLDivElement>) => {\n    timeout.current = setTimeout(() => {\n      wasLongPress.current = true;\n      onLongPressComplete(event);\n      cancelTimeout();\n    }, duration);\n  };\n\n  const onPressUp = (event: React.TouchEvent<HTMLDivElement>) => {\n    if (timeout.current === undefined) return;\n    cancelTimeout();\n    onLongPressCancel?.(event);\n  };\n\n  return { onPressDown, onPressUp, wasLongPress };\n};\n","import { CheckBox } from \"grommet\";\nimport { Modal } from \"./Modal\";\n\nexport const SettingsModal = ({\n  onClickOutside,\n  resetMode,\n  isDarkMode,\n}: {\n  isDarkMode: boolean;\n  onClickOutside: () => void;\n  resetMode: (value: boolean) => void;\n}) => {\n  return (\n    <Modal onClose={onClickOutside} heading={\"Settings\"}>\n      <CheckBox\n        toggle\n        onChange={(event) => resetMode(event.target.checked)}\n        label={\"Dark Mode\"}\n        checked={isDarkMode}\n      />\n    </Modal>\n  );\n};\n","import { IconProps } from \"grommet-icons\";\nimport { StyledIcon } from \"grommet-icons/StyledIcon\";\n\nexport const DropperIcon = (props: IconProps) => (\n  <StyledIcon viewBox=\"0 0 6.35 6.35\" a11yTitle=\"Dropper\" {...props}>\n    <g fill=\"none\" stroke=\"#000\" strokeWidth=\".52917\">\n      <path d=\"m5.5002.60932c-.20131-.12441-.4432-.27888-.67352-.22451-.30901.072947-.38019.55202-.67352.67352-.13828.057276-.44901 0-.44901 0l-.22451.22451.22451.22451-2.9186 2.9186-.44901 1.347.22451.22451 1.347-.44901 2.9186-2.9186.22451.22451.22451-.22451s-.057276-.31073 1e-7-.44901c.1215-.29333.60057-.36451.67352-.67352.054371-.23032-.10009-.47221-.22451-.67352-.05564-.090027-.13448-.16887-.22451-.22451z\" />\n      <path d=\"m3.7042 1.5073 1.1225 1.1225\" />\n    </g>\n  </StyledIcon>\n);\n","import { IconProps } from \"grommet-icons\";\nimport { StyledIcon } from \"grommet-icons/StyledIcon\";\n\nexport const PaletteIcon = (props: IconProps) => (\n  <StyledIcon viewBox=\"0 0 6.35 6.35\" a11yTitle=\"Palette\" {...props}>\n    <path\n      xmlns=\"http://www.w3.org/2000/svg\"\n      d=\"m5.926 3.1543c-.037745.39288-.36536.56457-.83971.54908-.38933-.01271-1.2873-.15741-1.475.24331-.22247.47492.58533.95042.5725 1.4362-.011288.42757-.61548.57263-1.0208.57263-1.526 0-2.763-1.2542-2.763-2.8012 2e-8-1.5471 1.237-2.8012 2.763-2.8012 1.526 0 2.911 1.2612 2.763 2.8012z\"\n      fillOpacity=\"0\"\n      strokeWidth=\".52917\"\n    />\n    <circle cx=\"1.5769\" cy=\"3.5063\" r=\"0.3784252\" stroke=\"none\" />\n    <circle cx=\"1.8923\" cy=\"2.1661\" r=\"0.3784252\" stroke=\"none\" />\n    <circle cx=\"3.8408\" cy=\"1.7492\" r=\"0.3784252\" stroke=\"none\" />\n    <circle cx=\"2.7456\" cy=\"1.4877\" r=\"0.3784252\" stroke=\"none\" />\n  </StyledIcon>\n);\n","import { Button, ButtonProps } from \"grommet\";\nexport const HighlightableButton = ({\n  onClick,\n  isHighlighted,\n  ...props\n}: {\n  onClick: () => void;\n  isHighlighted: boolean;\n} & ButtonProps &\n  Omit<JSX.IntrinsicElements[\"button\"], \"color\">) => {\n  return (\n    <Button\n      onClick={onClick}\n      style={{\n        borderRadius: \"18px\",\n        boxShadow: isHighlighted ? \"0 0 2px 2px green\" : \"none\",\n      }}\n      {...props}\n    />\n  );\n};\n","import { Box, Button, Grid } from \"grommet\";\nimport {\n  Brush,\n  Erase,\n  Grid as GridIcon,\n  History,\n  Pin,\n  Redo,\n  Trash,\n  Undo,\n  Paint,\n} from \"grommet-icons\";\nimport { DropperIcon } from \"./components/DropperIcon\";\nimport { PaletteIcon } from \"./components/PaletteIcon\";\nimport { RGBColor } from \"./drivers/Color\";\nimport { HighlightableButton } from \"./HighlightableButton\";\nimport { Tools } from \"./Tools\";\n\nexport const ToolsBanner = ({\n  onToolChange,\n  onPickerModeClick,\n  onUndoClick,\n  onRedoClick,\n  onPaletteButtonClick,\n  onGridButtonClick,\n  onTrashClick,\n  isGridShown,\n  color,\n  pickerMode,\n  tool,\n}: {\n  onPickerModeClick: (pickerMode: \"history\" | \"pinned\") => void;\n  onUndoClick: () => void;\n  onRedoClick: () => void;\n  onPaletteButtonClick: () => void;\n  onGridButtonClick: () => void;\n  onTrashClick: () => void;\n  onToolChange: (tool: Tools) => void;\n  pickerMode: \"history\" | \"pinned\";\n  tool: Tools;\n  isGridShown: boolean;\n  color: RGBColor;\n}) => {\n  return (\n    <Box height=\"xsmall\">\n      <Grid\n        fill\n        columns={[\"auto\", \"auto\"]}\n        rows={[\"flex\", \"flex\"]}\n        areas={[\n          { name: \"left-top\", start: [0, 0], end: [0, 0] },\n          { name: \"left-bot\", start: [0, 1], end: [0, 1] },\n          { name: \"right-top\", start: [1, 0], end: [1, 0] },\n          { name: \"right-bot\", start: [1, 1], end: [1, 1] },\n        ]}\n      >\n        <Box gridArea=\"left-top\" direction=\"row\">\n          <HighlightableButton\n            primary\n            onClick={() => onToolChange(\"paint\")}\n            isHighlighted={tool === \"paint\"}\n            icon={<Brush />}\n            color={color.toHex()}\n          />\n          <HighlightableButton\n            onClick={() => onToolChange(\"eraser\")}\n            isHighlighted={tool === \"eraser\"}\n            icon={<Erase />}\n          />\n          <HighlightableButton\n            primary\n            onClick={() => onToolChange(\"fill\")}\n            isHighlighted={tool === \"fill\"}\n            icon={<Paint />}\n            color={color.toHex()}\n          />\n          <Button onClick={onPaletteButtonClick} icon={<PaletteIcon />} />\n          <HighlightableButton\n            onClick={() => onToolChange(\"dropper\")}\n            isHighlighted={tool === \"dropper\"}\n            icon={<DropperIcon />}\n          />\n        </Box>\n        <Box gridArea=\"left-bot\" direction=\"row\">\n          <HighlightableButton\n            icon={<History />}\n            onClick={() => onPickerModeClick(\"history\")}\n            isHighlighted={pickerMode === \"history\"}\n          />\n          <HighlightableButton\n            icon={<Pin />}\n            onClick={() => onPickerModeClick(\"pinned\")}\n            isHighlighted={pickerMode === \"pinned\"}\n          />\n        </Box>\n        <Box gridArea=\"right-top\" direction=\"row\" justify=\"end\">\n          <Button icon={<Undo />} onClick={onUndoClick} />\n          <Button icon={<Redo />} onClick={onRedoClick} />\n        </Box>\n        <Box gridArea=\"right-bot\" direction=\"row\" justify=\"end\">\n          <Button onClick={onTrashClick} icon={<Trash />} />\n          <HighlightableButton\n            onClick={onGridButtonClick}\n            isHighlighted={isGridShown}\n            icon={<GridIcon />}\n          />\n        </Box>\n      </Grid>\n    </Box>\n  );\n};\n","import { Grid, grommet, Grommet, Header, Main } from \"grommet\";\nimport React, { useCallback, useMemo, useState } from \"react\";\nimport { BodyColorPicker } from \"./BodyColorPicker\";\nimport { CanvasStack } from \"./CanvasStack\";\nimport { ValidDimensions } from \"./components/DimensionPicker\";\nimport { ConfirmModal, ConfirmModalProps } from \"./ConfirmModal\";\nimport { RGBColor } from \"./drivers/Color\";\nimport { UndoablePaintCanvas } from \"./drivers/UndoablePaintCanvas\";\nimport { Footer } from \"./Footer\";\nimport { NewPageModal } from \"./NewPageModal\";\nimport { AvailablePalettes } from \"./PaletteDictionary\";\nimport { PaletteModal } from \"./PaletteModal\";\nimport { SettingsModal } from \"./SettingsModal\";\nimport { Brushes, Tools } from \"./Tools\";\nimport { ToolsBanner } from \"./ToolsBanner\";\n\nconst defaultPalette = \"cga\";\nconst defaultColor = \"#5555ff\";\n\nconst App = () => {\n  const [pixelDimensions, setPixelDimensions] = useState<ValidDimensions>(16);\n  const [color, setColor] = useState<RGBColor>(\n    RGBColor.fromHexString(defaultColor)\n  );\n\n  const [confirmModalParameters, createModal] = useState<\n    ConfirmModalProps | undefined\n  >(undefined);\n\n  const [tool, setTool] = useState<Tools>(\"paint\");\n  const [brush, setToolAndBrush] = useStickyBrush(\"paint\", setTool);\n  const [pickerMode, setPickerMode] = useState<\"history\" | \"pinned\">(\"pinned\");\n  const [isGridShown, setGridShown] = useState(false);\n  const [isPaletteModalShown, setPaletteMenuShown] = useState(false);\n  const [palette, setPalette] = useState<AvailablePalettes>(defaultPalette);\n  const [isNewPageModalShown, setCreateMenuShown] = useState(false);\n  const [isSettingsMenuShown, setSettingsMenuShown] = useState(false);\n  const [darkMode, setDarkMode] = useState(false);\n  const [canvas, setCanvas] = useState<undefined | HTMLCanvasElement>();\n  const [pinnedColors, setPinnedColors] = useState<RGBColor[]>([]);\n  const [colorHistory, setColorHistory] = useState<RGBColor[]>([]);\n\n  const paint = useMemo(() => {\n    return new UndoablePaintCanvas(pixelDimensions);\n  }, [pixelDimensions]);\n\n  const onCanvasTouch = (\n    canvas: HTMLCanvasElement,\n    event: React.TouchEvent<HTMLCanvasElement>\n  ): void => {\n    switch (tool) {\n      case \"dropper\": {\n        setTool(brush);\n        const coords = paint.touchToCoords(event);\n        const selectedColor = paint.getColorAt(coords.quantX, coords.quantY);\n        if (selectedColor === RGBColor.NO_COLOR) break;\n        setColor(selectedColor);\n        break;\n      }\n      case \"paint\": {\n        paint.setCanvas(canvas);\n        paint.touchEvent(event, color);\n        paint.drawToCanvas();\n        break;\n      }\n      case \"eraser\": {\n        paint.setCanvas(canvas);\n        paint.touchEvent(event, RGBColor.NO_COLOR);\n        paint.drawToCanvas();\n        break;\n      }\n      case \"fill\": {\n        paint.setCanvas(canvas);\n        const coords = paint.touchToCoords(event);\n        paint.fillWithColor(coords.quantX, coords.quantY, color);\n        paint.drawToCanvas();\n\n        break;\n      }\n    }\n  };\n\n  const onCanvasCreated = (canvas: HTMLCanvasElement): void => {\n    setCanvas(canvas);\n    paint.setCanvas(canvas);\n  };\n\n  const onUndoClick = () => {\n    paint.undo();\n    paint.drawToCanvas();\n  };\n\n  const onRedoClick = () => {\n    paint.redo();\n    paint.drawToCanvas();\n  };\n\n  const onPaletteButtonClick = () => setPaletteMenuShown(!isPaletteModalShown);\n  const onGridButtonClick = () => setGridShown(!isGridShown);\n\n  const onTrashClick = () =>\n    createModal({\n      onAccept: () => {\n        createModal(undefined);\n\n        paint.clear();\n        paint.drawToCanvas();\n      },\n      message: \"Are you sure you want to clear the canvas?\",\n      acceptButtonText: \"Clear\",\n      onCancel: () => {\n        createModal(undefined);\n      },\n      onClose: () => createModal(undefined),\n    });\n  const setColorAndTurnOffPicker = (color: RGBColor): void => {\n    setColor(color);\n    setTool(brush);\n  };\n\n  const isConfirmModalShown = !!confirmModalParameters;\n  /**\n   * TODO: Add darkmode and settings modal\n   */\n  return (\n    <Grommet\n      theme={grommet}\n      style={{ height: \"100%\" }}\n      themeMode={darkMode ? \"dark\" : \"light\"}\n    >\n      <Grid\n        fill\n        areas={[\n          { name: \"header\", start: [0, 0], end: [0, 0] },\n          { name: \"canvas\", start: [0, 1], end: [0, 1] },\n          { name: \"body\", start: [0, 2], end: [0, 2] },\n          { name: \"footer\", start: [0, 3], end: [0, 3] },\n        ]}\n        columns={[\"full\"]}\n        rows={[\"xxsmall\", \"auto\", \"flex\", \"xxsmall\"]}\n      >\n        <Header gridArea=\"header\" justify=\"center\">\n          Pixel Pixy\n        </Header>\n        <CanvasStack\n          stackProps={{ gridArea: \"canvas\", interactiveChild: \"first\" }}\n          isGridShown={isGridShown}\n          isPaletteMenuShown={isPaletteModalShown}\n          onCanvasCreated={onCanvasCreated}\n          onCanvasTouch={onCanvasTouch}\n          pixelDimensions={pixelDimensions}\n        />\n\n        <Main gridArea=\"body\" pad=\"small\" elevation=\"xsmall\">\n          <ToolsBanner\n            color={color}\n            tool={tool}\n            isGridShown={isGridShown}\n            onPickerModeClick={setPickerMode}\n            onToolChange={setToolAndBrush}\n            onGridButtonClick={onGridButtonClick}\n            onPaletteButtonClick={onPaletteButtonClick}\n            onRedoClick={onRedoClick}\n            onUndoClick={onUndoClick}\n            onTrashClick={onTrashClick}\n            pickerMode={pickerMode}\n          />\n\n          <BodyColorPicker\n            setColorHistory={setColorHistory}\n            colorHistory={colorHistory}\n            pickerMode={pickerMode}\n            color={color}\n            palette={palette}\n            pinnedColors={pinnedColors}\n            setColorAndTurnOffPicker={setColorAndTurnOffPicker}\n          />\n        </Main>\n        {canvas && (\n          <Footer\n            gridArea=\"footer\"\n            canvas={canvas}\n            onAddButtonClicked={() => setCreateMenuShown(true)}\n            setSettingsMenuShown={setSettingsMenuShown}\n          />\n        )}\n      </Grid>\n\n      {isPaletteModalShown && (\n        <PaletteModal\n          pinnedColors={pinnedColors}\n          setPinnedColors={setPinnedColors}\n          onCancel={() => setPaletteMenuShown(false)}\n          setColor={setColorAndTurnOffPicker}\n          palette={palette}\n          setPalette={setPalette}\n        />\n      )}\n\n      {isConfirmModalShown && (\n        <ConfirmModal\n          onClose={confirmModalParameters!.onClose}\n          onAccept={confirmModalParameters!.onAccept}\n          onCancel={confirmModalParameters!.onCancel}\n          cancelButtonText={confirmModalParameters!.cancelButtonText}\n          acceptButtonText={confirmModalParameters!.acceptButtonText}\n          message={confirmModalParameters!.message}\n        />\n      )}\n\n      {isNewPageModalShown && (\n        <NewPageModal\n          currentDimension={pixelDimensions}\n          onCancel={() => setCreateMenuShown(false)}\n          onCreateNew={(dimension, maybeLoadedImage) => {\n            paint.clear();\n            if (dimension !== pixelDimensions) {\n              setPixelDimensions(dimension);\n            }\n            if (maybeLoadedImage !== undefined) {\n              paint.setPixelsFromImage(maybeLoadedImage);\n            }\n            paint.drawToCanvas();\n            setCreateMenuShown(false);\n          }}\n        />\n      )}\n\n      {isSettingsMenuShown && (\n        <SettingsModal\n          isDarkMode={darkMode}\n          onClickOutside={() => setSettingsMenuShown(false)}\n          resetMode={setDarkMode}\n        />\n      )}\n    </Grommet>\n  );\n};\n\nconst useStickyBrush = (\n  defaultBrush: Brushes,\n  setTool: (tool: Tools) => void\n) => {\n  const [brush, setBrush] = useState<Brushes>(defaultBrush);\n\n  const setToolAndBrush = useCallback(\n    (tool: Tools) => {\n      switch (tool) {\n        case \"fill\": {\n          setBrush(\"fill\");\n          break;\n        }\n        case \"paint\": {\n          setBrush(\"paint\");\n          break;\n        }\n      }\n\n      setTool(tool);\n    },\n    [setTool]\n  );\n\n  return [brush, setToolAndBrush] as const;\n};\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./styles/index.css\";\nimport App from \"./App\";\n\nwindow.oncontextmenu = function (event: MouseEvent) {\n  event.preventDefault();\n  event.stopPropagation();\n  return false;\n};\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}