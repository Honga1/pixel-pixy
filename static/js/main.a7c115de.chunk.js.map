{"version":3,"sources":["drivers/getRelativeClickPosition.tsx","components/CanvasContainer.tsx","components/ClearButton.tsx","components/ColorSquare.tsx","components/ColorPickerHistory.tsx","components/ColorPickerSwatch.tsx","components/CurrentColor.tsx","components/Select.tsx","components/DimensionPicker.tsx","components/Grid.tsx","components/LoadButton.tsx","components/SaveButton.tsx","components/ToggleButton.tsx","drivers/HSLColor.ts","drivers/RGBColor.ts","drivers/KeyPairMap.ts","drivers/PaintCanvas.ts","drivers/UndoRedoBuffer.ts","drivers/UndoBuffer.ts","drivers/UndoablePaintCanvas.ts","App.tsx","index.tsx"],"names":["getRelativeClickPosition","event","screenX","changedTouches","clientX","screenY","clientY","rect","target","getBoundingClientRect","clip","value","min","max","Math","clippedX","left","width","clippedY","top","height","relativeX","relativeY","CanvasContainer","onCanvasCreated","onTouchEvent","pixelDimensions","canvasRef","useRef","useEffect","canvas","current","onInnerTouchEvent","className","style","backgroundSize","ref","onTouchEnd","onTouchMove","ClearButton","onClearPressed","ColorSquare","color","backgroundColor","toHex","ColorPickerHistory","colorSelected","onColorPicked","useState","colorHistory","setColorHistory","newColorHistory","unshift","length","slice","map","index","ColorPickerSwatch","selectedColor","toHSL","currentHSL","setCurrentHSL","hsl","h","scaledX","scaledY","s","l","clone","toRGB","CurrentColor","Select","props","onChange","e","selectedIndex","currentTarget","selectedOption","options","option","label","validDimensions","DimensionPicker","dimension","onDimensionChange","Grid","rootCanvas","context","getContext","clearRect","strokeStyle","lineWidth","xIncrement","xIndex","moveTo","round","lineTo","stroke","yIncrement","yIndex","clientWidth","clientHeight","LoadButton","setLoadedImage","a","imagePromise","Promise","resolve","reject","files","imageUrl","URL","createObjectURL","image","Image","src","onload","type","accept","SaveButton","fullScaleCanvas","document","createElement","window","innerWidth","imageSmoothingEnabled","drawImage","toDataURL","href","download","ToggleButton","onToggle","text","HSLColor","hue","saturation","lightness","this","hslString","sep","indexOf","substr","split","hString","parseFloat","PI","r","g","b","cMin","cMax","delta","abs","RGBColor","fromHSL","red","green","blue","rgb","RangeError","c","x","m","hex","Number","isInteger","TypeError","hexString","toString","fromHexString","rgbString","rgbChunks","rgbValues","R","parseInt","rString","gString","bString","fromRGB","r1","g1","b1","r2","g2","b2","NO_COLOR","Symbol","iterator","toStringTag","KeyPairMap","keyPairMap","Map","keyA","keyB","set","clear","get","delete","callbackfn","thisArg","toRefMap","forEach","tempMap","innerMap","outerMap","keys","has","entries","values","lines","key","push","join","size","PaintCanvas","pixelMap","y","undefined","Error","DrawToCanvas","AreDimensionsCompatible","naturalWidth","naturalHeight","setPixelsFromCanvas","xIntervals","yIntervals","mutableMap","data","getImageData","maybeColor","result","paintCanvas","fillStyle","fillRect","sqrt","quantX","floor","quantY","currentColor","getColorAt","Equals","setColorAt","UndoRedoBuffer","redoBuffer","Array","maybeTop","getBufferLength","redid","pop","base","maxSize","buffer","maybeReverseState","UndoablePaintCanvas","undoBuffer","getPixelMap","addCurrent","undo","setPixelMap","redo","redoOne","App","setPixelDimensions","setColor","isGridShown","setGridShown","isPickerShown","setPickerShown","setCanvas","paint","useMemo","touchEvent","drawToCanvas","setPixelsFromImage","hasCanvas","console","warn","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.a7c115de.chunk.js","sourcesContent":["import { TouchEvent } from \"react\";\n\nexport function getRelativeClickPosition(\n  event: TouchEvent<HTMLElement>\n): { relativeX: number; relativeY: number } {\n  const screenX = event.changedTouches[0].clientX;\n  const screenY = event.changedTouches[0].clientY;\n  const rect = (event.target as HTMLElement).getBoundingClientRect();\n\n  const clip = (value: number, min: number, max: number) =>\n    Math.min(max, Math.max(value, min));\n\n  const clippedX = clip(screenX - rect.left, 0, rect.width - 1);\n  const clippedY = clip(screenY - rect.top, 0, rect.height - 1);\n\n  const relativeX = clippedX / rect.width;\n  const relativeY = clippedY / rect.height;\n  return { relativeX: relativeX, relativeY: relativeY };\n}\n","import { TouchEvent, useEffect, useRef } from \"react\";\nimport { getRelativeClickPosition } from \"../drivers/getRelativeClickPosition\";\nimport \"../styles/CanvasContainer.css\";\n\nconst debug = false;\nexport const CanvasContainer = ({\n  onCanvasCreated,\n  onTouchEvent,\n  pixelDimensions,\n}: {\n  pixelDimensions: number;\n  onCanvasCreated: (canvas: HTMLCanvasElement) => void;\n  onTouchEvent: (\n    canvas: HTMLCanvasElement,\n    touchEvent: TouchEvent<HTMLCanvasElement>\n  ) => void;\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const debugCanvasRef = useRef<HTMLCanvasElement>(null);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (canvas) {\n      onCanvasCreated(canvas);\n    }\n  }, [onCanvasCreated]);\n\n  const onInnerTouchEvent = (event: TouchEvent<HTMLCanvasElement>) => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    onTouchEvent(canvas, event);\n\n    if (debug) {\n      const { relativeX, relativeY } = getRelativeClickPosition(event);\n      const maybeContext = debugCanvasRef.current?.getContext(\"2d\");\n      if (!maybeContext) return;\n      maybeContext.fillStyle = \"red\";\n      maybeContext.fillRect(\n        relativeX * window.innerWidth,\n        relativeY * window.innerHeight,\n        10,\n        10\n      );\n    }\n  };\n\n  return (\n    <div className=\"CanvasContainer\">\n      <div>\n        <canvas\n          style={{\n            backgroundSize: `${100 / pixelDimensions / 2}%`,\n          }}\n          ref={canvasRef}\n          width={pixelDimensions}\n          height={pixelDimensions}\n          onTouchEnd={onInnerTouchEvent}\n          onTouchMove={onInnerTouchEvent}\n        ></canvas>\n        {debug && (\n          <canvas\n            style={{\n              background: \"none\",\n              position: \"absolute\",\n              pointerEvents: \"none\",\n            }}\n            ref={debugCanvasRef}\n            width={window.innerWidth}\n            height={window.innerHeight}\n          ></canvas>\n        )}\n      </div>\n    </div>\n  );\n};\n","export const ClearButton = ({\n  onClearPressed,\n}: {\n  onClearPressed: () => void;\n}) => {\n  return <button onTouchEnd={onClearPressed}>Clear Canvas</button>;\n};\n","import \"../styles/ColorSquare.css\";\nimport { TouchEvent } from \"react\";\nimport { RGBColor } from \"../drivers/RGBColor\";\n\nexport const ColorSquare = ({\n  color,\n  onTouchEnd,\n}: {\n  color: RGBColor;\n  onTouchEnd?: (event: TouchEvent<HTMLDivElement>) => void;\n}) => {\n  return (\n    <div\n      onTouchEnd={onTouchEnd}\n      style={{ backgroundColor: color.toHex() }}\n      className=\"ColorSquare\"\n    ></div>\n  );\n};\n","import { useEffect, useState } from \"react\";\nimport { ColorSquare } from \"./ColorSquare\";\nimport { RGBColor } from \"../drivers/RGBColor\";\nimport \"../styles/ColorPickerHistory.css\";\n\nexport const ColorPickerHistory = ({\n  colorSelected,\n  onColorPicked,\n}: {\n  colorSelected: RGBColor;\n  onColorPicked: (color: RGBColor) => void;\n}) => {\n  const [colorHistory, setColorHistory] = useState<RGBColor[]>([]);\n\n  useEffect(() => {\n    let newColorHistory = [...colorHistory];\n    newColorHistory.unshift(colorSelected);\n    if (newColorHistory.length > 8) {\n      newColorHistory = newColorHistory.slice(0, 8);\n    }\n\n    setColorHistory(newColorHistory);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [colorSelected]);\n\n  return (\n    <div className=\"ColorPickerHistory\">\n      Color History\n      <div className=\"RowZero\">\n        {colorHistory.map((color, index) => (\n          <ColorSquare\n            onTouchEnd={() => onColorPicked(color)}\n            key={index}\n            color={color}\n          />\n        ))}\n      </div>\n    </div>\n  );\n};\n","import { useState, useEffect } from \"react\";\nimport { RGBColor } from \"../drivers/RGBColor\";\nimport { getRelativeClickPosition } from \"../drivers/getRelativeClickPosition\";\nimport \"../styles/ColorPickerSwatch.css\";\nexport const ColorPickerSwatch = ({\n  selectedColor,\n  onColorPicked,\n}: {\n  selectedColor: RGBColor;\n  onColorPicked: (color: RGBColor) => void;\n}) => {\n  const [currentHSL, setCurrentHSL] = useState(() => {\n    const hsl = selectedColor.toHSL();\n\n    return hsl;\n  });\n\n  useEffect(() => {\n    // Extract HSl from string\n    const hsl = selectedColor.toHSL();\n    if (hsl) {\n      setCurrentHSL(hsl);\n    }\n  }, [selectedColor]);\n\n  return (\n    <div className=\"Wrapper\">\n      <div\n        style={{ backgroundColor: `hsl(${currentHSL.h}, 100%, 50%)` }}\n        className=\"ColorPickerSwatch\"\n      >\n        <div\n          className=\"Saturation\"\n          onTouchEnd={(event) => {\n            const {\n              relativeX: scaledX,\n              relativeY: scaledY,\n            } = getRelativeClickPosition(event);\n            currentHSL.s = scaledX;\n            currentHSL.l = (1 - scaledY) * (1 - currentHSL.s / 2);\n            setCurrentHSL(currentHSL.clone());\n            onColorPicked(currentHSL.toRGB());\n          }}\n          onTouchMove={(event) => {\n            const {\n              relativeX: scaledX,\n              relativeY: scaledY,\n            } = getRelativeClickPosition(event);\n            currentHSL.s = scaledX;\n            currentHSL.l = (1 - scaledY) * (1 - currentHSL.s / 2);\n            setCurrentHSL(currentHSL.clone());\n          }}\n        >\n          <div className=\"Lightness\" />\n        </div>\n\n        <div\n          className=\"Hue\"\n          onTouchEnd={(event) => {\n            const { relativeX: scaledX } = getRelativeClickPosition(event);\n            currentHSL.h = scaledX * 360;\n            setCurrentHSL(currentHSL.clone());\n          }}\n          onTouchMove={(event) => {\n            const { relativeX: scaledX } = getRelativeClickPosition(event);\n            currentHSL.h = scaledX * 360;\n            setCurrentHSL(currentHSL.clone());\n          }}\n        ></div>\n      </div>\n    </div>\n  );\n};\n","import { ColorSquare } from \"./ColorSquare\";\nimport { RGBColor } from \"../drivers/RGBColor\";\nimport \"../styles/CurrentColor.css\";\n\nexport const CurrentColor = ({ color }: { color: RGBColor }) => {\n  return (\n    <div className=\"CurrentColor\">\n      <div>CurrentColor</div>\n      <ColorSquare color={color}></ColorSquare>\n    </div>\n  );\n};\n","type OptionValue = string | number;\n\nexport type Option<T extends OptionValue> = {\n  value: T;\n  label: string;\n};\n\ntype Props<T extends OptionValue> = {\n  options: readonly Option<T>[];\n  value: T;\n  onChange: (value: T) => void;\n};\n\nexport function Select<T extends OptionValue>(props: Props<T>) {\n  function handleOnChange(e: React.FormEvent<HTMLSelectElement>) {\n    const { selectedIndex } = e.currentTarget;\n    const selectedOption = props.options[selectedIndex];\n    props.onChange(selectedOption.value);\n  }\n  return (\n    <select value={props.value} onChange={handleOnChange}>\n      {props.options.map((option) => (\n        <option key={option.value} value={option.value}>\n          {option.label}\n        </option>\n      ))}\n    </select>\n  );\n}\n","import { ReactElement } from \"react\";\nimport { Select } from \"./Select\";\nimport \"../styles/DimensionPicker.css\";\n\nconst validDimensions = [\n  { value: 1, label: \"1x1\" },\n  { value: 8, label: \"8x8\" },\n  { value: 10, label: \"10x10\" },\n  { value: 12, label: \"12x12\" },\n  { value: 14, label: \"14x14\" },\n  { value: 16, label: \"16x16\" },\n  { value: 18, label: \"18x18\" },\n  { value: 20, label: \"20x20\" },\n  { value: 22, label: \"22x22\" },\n  { value: 24, label: \"24x24\" },\n] as const;\n\nexport type ValidDimensions = typeof validDimensions[number][\"value\"];\n\nexport const DimensionPicker = ({\n  dimension,\n  onDimensionChange,\n}: {\n  dimension: ValidDimensions;\n  onDimensionChange: (dimension: ValidDimensions) => void;\n}): ReactElement => {\n  return (\n    <label>\n      Dimension\n      <Select\n        onChange={onDimensionChange}\n        options={validDimensions}\n        value={dimension}\n      ></Select>\n    </label>\n  );\n};\n","import { useEffect, useRef } from \"react\";\nimport \"../styles/Grid.css\";\n\nexport const Grid = ({\n  pixelDimensions,\n  rootCanvas,\n}: {\n  pixelDimensions: number;\n  rootCanvas: HTMLCanvasElement;\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const context = canvas?.getContext(\"2d\");\n\n    if (!context || !canvas) return;\n\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    context.strokeStyle = \"lightgrey\";\n    context.lineWidth = 1;\n    const xIncrement = canvas.width / pixelDimensions;\n    for (let xIndex = 0; xIndex < pixelDimensions; xIndex++) {\n      context.moveTo(Math.round(xIndex * xIncrement), 0);\n      context.lineTo(Math.round(xIndex * xIncrement), canvas.height);\n      context.stroke();\n    }\n\n    // Horizontal lines\n    const yIncrement = canvas.height / pixelDimensions;\n    for (let yIndex = 0; yIndex < pixelDimensions; yIndex++) {\n      context.moveTo(0, Math.round(yIndex * yIncrement));\n      context.lineTo(canvas.width, Math.round(yIndex * yIncrement));\n      context.stroke();\n    }\n\n    return () => {\n      context.clearRect(0, 0, canvas.width, canvas.height);\n    };\n  });\n  return (\n    <canvas\n      ref={canvasRef}\n      key={pixelDimensions}\n      className=\"Grid\"\n      width={rootCanvas.clientWidth}\n      height={rootCanvas.clientHeight}\n    ></canvas>\n  );\n};\n","export const LoadButton = ({\n  setLoadedImage,\n}: {\n  setLoadedImage: (image: HTMLImageElement) => void;\n}) => {\n  return (\n    <label>\n      Upload Image\n      <input\n        onChange={async (event) => {\n          const imagePromise = new Promise<HTMLImageElement>(\n            (resolve, reject) => {\n              if (!event.target.files || !event.target.files[0]) return;\n              const imageUrl = URL.createObjectURL(event.target.files![0]);\n              const image = new Image();\n              image.src = imageUrl;\n              image.onload = () => resolve(image);\n            }\n          );\n          const image = await imagePromise;\n          event.target.value = \"\";\n          setLoadedImage(image);\n        }}\n        type=\"file\"\n        accept=\"image/*\"\n      />\n    </label>\n  );\n};\n","export const SaveButton = ({ canvas }: { canvas: HTMLCanvasElement }) => {\n  return (\n    <a\n      onTouchEnd={(event) => {\n        const fullScaleCanvas = document.createElement(\"canvas\");\n        fullScaleCanvas.width = window.innerWidth;\n        fullScaleCanvas.height = window.innerWidth;\n        const context = fullScaleCanvas.getContext(\"2d\")!;\n        context.imageSmoothingEnabled = false;\n        context.drawImage(\n          canvas,\n          0,\n          0,\n          fullScaleCanvas.width,\n          fullScaleCanvas.height\n        );\n\n        const image = fullScaleCanvas.toDataURL(\"image/png\");\n        (event.target as EventTarget & HTMLAnchorElement).href = image;\n      }}\n      href=\"/\"\n      download=\"my-pixel-art.png\"\n    >\n      Save\n    </a>\n  );\n};\n","export const ToggleButton = ({\n  onToggle,\n  text,\n}: {\n  onToggle: () => void;\n  text: string;\n}) => {\n  return <button onTouchEnd={onToggle}>{text}</button>;\n};\n","import { RGBColor } from \"./RGBColor\";\n\nexport class HSLColor {\n  /**\n   * @param hslString A string following the possible forms\n   * hsl(180 100% 50%)\n   * hsl(180deg,100%,50%)\n   * hsl(180deg 100% 50%)\n   * hsl(3.14rad,100%,50%)\n   * hsl(3.14rad 100% 50%)\n   * hsl(0.5turn,100%,50%)\n   * hsl(0.5turn 100% 50%)\n   */\n  static fromHSLString(hslString: string) {\n    let sep = hslString.indexOf(\",\") > -1 ? \",\" : \" \";\n    const hsl = hslString.substr(4).split(\")\")[0].split(sep);\n\n    let hString = hsl[0];\n    let s = parseFloat(hsl[1].substr(0, hsl[1].length - 1)) / 100;\n    let l = parseFloat(hsl[2].substr(0, hsl[2].length - 1)) / 100;\n\n    let h = 0;\n\n    if (hString.indexOf(\"deg\") > -1)\n      hString = hString.substr(0, hString.length - 3);\n    else if (hString.indexOf(\"rad\") > -1)\n      h = Math.round(\n        parseFloat(hString.substr(0, hString.length - 3)) * (180 / Math.PI)\n      );\n    else if (hString.indexOf(\"turn\") > -1)\n      h = Math.round(parseFloat(hString.substr(0, hString.length - 4)) * 360);\n    // Keep hue fraction of 360 if ending up over\n    if (h >= 360) h %= 360;\n\n    return new HSLColor(h, s, l);\n  }\n\n  static fromRGB(r: number, g: number, b: number) {\n    // Make r, g, and b fractions of 1\n    r /= 255;\n    g /= 255;\n    b /= 255;\n\n    // Find greatest and smallest channel values\n    let cMin = Math.min(r, g, b);\n    let cMax = Math.max(r, g, b);\n    let delta = cMax - cMin;\n    let h = 0;\n    let s = 0;\n    let l = 0;\n\n    // Calculate hue\n    // No difference\n    if (delta === 0) h = 0;\n    // Red is max\n    else if (cMax === r) h = ((g - b) / delta) % 6;\n    // Green is max\n    else if (cMax === g) h = (b - r) / delta + 2;\n    // Blue is max\n    else h = (r - g) / delta + 4;\n\n    h = Math.round(h * 60);\n\n    // Make negative hues positive behind 360°\n    if (h < 0) h += 360;\n\n    // Calculate lightness\n    l = (cMax + cMin) / 2;\n\n    // Calculate saturation\n    s = delta === 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));\n\n    return new HSLColor(h, s, l);\n  }\n\n  constructor(hue: number, saturation: number, lightness: number) {\n    this.hsl = [hue, saturation, lightness];\n  }\n\n  hsl: [number, number, number];\n\n  get h() {\n    return this.hsl[0];\n  }\n  get s() {\n    return this.hsl[1];\n  }\n  get l() {\n    return this.hsl[2];\n  }\n\n  set h(h: number) {\n    this.hsl[0] = h;\n  }\n  set s(s: number) {\n    this.hsl[1] = s;\n  }\n  set l(l: number) {\n    this.hsl[2] = l;\n  }\n\n  toHSLString() {\n    const [h, s, l] = this.hsl;\n    return \"hsl(\" + h + \",\" + s * 100 + \"%,\" + l * 100 + \"%)\";\n  }\n\n  toRGB(): RGBColor {\n    return RGBColor.fromHSL(...this.hsl);\n  }\n\n  clone(): HSLColor {\n    return new HSLColor(...this.hsl);\n  }\n}\n","import { HSLColor } from \"./HSLColor\";\n\nexport type NoColor = \"NO_COLOR\";\nexport class RGBColor {\n  static readonly NO_COLOR: NoColor = \"NO_COLOR\";\n  /**\n   * @param h Degrees\n   * @param s Percent\n   * @param l Percent\n   */\n\n  static fromHSL(h: number, s: number, l: number) {\n    if (h < 0 || h > 359) {\n      throw new RangeError(\"Hue should be between 0 and 359 inclusive\");\n    }\n    if (s < 0 || s > 1) {\n      throw new RangeError(\n        \"Saturation is a percentage and should be between 0 and 1 inclusive\"\n      );\n    }\n    if (l < 0 || l > 1) {\n      throw new RangeError(\n        \"Lightness is a percentage and should be between 0 and 1 inclusive\"\n      );\n    }\n\n    let c = (1 - Math.abs(2 * l - 1)) * s;\n    let x = c * (1 - Math.abs(((h / 60) % 2) - 1));\n    let m = l - c / 2;\n    let r = 0;\n    let g = 0;\n    let b = 0;\n\n    if (0 <= h && h < 60) {\n      r = c;\n      g = x;\n      b = 0;\n    } else if (60 <= h && h < 120) {\n      r = x;\n      g = c;\n      b = 0;\n    } else if (120 <= h && h < 180) {\n      r = 0;\n      g = c;\n      b = x;\n    } else if (180 <= h && h < 240) {\n      r = 0;\n      g = x;\n      b = c;\n    } else if (240 <= h && h < 300) {\n      r = x;\n      g = 0;\n      b = c;\n    } else if (300 <= h && h < 360) {\n      r = c;\n      g = 0;\n      b = x;\n    }\n    r = Math.round((r + m) * 255);\n    g = Math.round((g + m) * 255);\n    b = Math.round((b + m) * 255);\n\n    return new RGBColor(r, g, b);\n  }\n\n  /**\n   * @param hex A number between 0-16777215\n   */\n  static fromHex(hex: number) {\n    if (!Number.isInteger(hex))\n      throw new TypeError(`Number should be an integer, got: ${hex}`);\n    if (hex < 0 || hex > (2 ^ 24)) {\n      throw new RangeError(\"Number should be between 0-16777215 inclusive\");\n    }\n\n    const hexString = hex.toString(16);\n\n    return RGBColor.fromHexString(\"#\" + hexString);\n  }\n\n  static fromRGBString(rgbString: string) {\n    let sep = rgbString.indexOf(\",\") > -1 ? \",\" : \" \";\n    const rgbChunks = rgbString.substr(4).split(\")\")[0].split(sep);\n    const rgbValues: number[] = [];\n\n    for (let R in rgbChunks) {\n      let r = rgbChunks[R];\n      if (r.indexOf(\"%\") > -1)\n        rgbValues[R] =\n          Math.round(parseFloat(r.substr(0, r.length - 1)) / 100) * 255;\n    }\n\n    const r = rgbValues[0];\n    const g = rgbValues[1];\n    const b = rgbValues[2];\n\n    return new RGBColor(r, g, b);\n  }\n\n  static fromHexString(hexString: string) {\n    if (hexString.length !== 7) {\n      throw new TypeError(\n        \"Hex string is not 7 characters long. Got: \" + hexString\n      );\n    }\n\n    if (hexString[0] !== \"#\") {\n      throw new TypeError(\n        \"Hex color string should start with #. Got: \" + hexString[0]\n      );\n    }\n\n    const r = parseInt(\"0x\" + hexString[1] + hexString[2], 16);\n    const g = parseInt(\"0x\" + hexString[3] + hexString[4], 16);\n    const b = parseInt(\"0x\" + hexString[5] + hexString[6], 16);\n\n    return new RGBColor(r, g, b);\n  }\n\n  constructor(red: number, green: number, blue: number) {\n    this.rgb = [red, green, blue];\n  }\n\n  rgb: [number, number, number];\n\n  get r() {\n    return this.rgb[0];\n  }\n  get g() {\n    return this.rgb[1];\n  }\n  get b() {\n    return this.rgb[2];\n  }\n\n  set r(r: number) {\n    this.rgb[0] = r;\n  }\n  set g(g: number) {\n    this.rgb[1] = g;\n  }\n  set b(b: number) {\n    this.rgb[2] = b;\n  }\n\n  static Equals(a: RGBColor, b: RGBColor) {\n    const [r1, g1, b1] = a.rgb;\n    const [r2, g2, b2] = b.rgb;\n\n    return r1 === r2 && g1 === g2 && b1 === b2;\n  }\n\n  toHex() {\n    const [r, g, b] = this.rgb;\n    let rString = r.toString(16);\n    let gString = g.toString(16);\n    let bString = b.toString(16);\n\n    if (rString.length === 1) rString = \"0\" + rString;\n    if (gString.length === 1) gString = \"0\" + gString;\n    if (bString.length === 1) bString = \"0\" + bString;\n\n    return \"#\" + rString + gString + bString;\n  }\n\n  toHSL(): HSLColor {\n    return HSLColor.fromRGB(...this.rgb);\n  }\n}\n","export class KeyPairMap<KeyA, KeyB, Value> implements Map<[KeyA, KeyB], Value> {\n  constructor(keyPairMap?: KeyPairMap<KeyA, KeyB, Value>) {\n    if (!keyPairMap) return;\n\n    for (let [[keyA, keyB], value] of keyPairMap) {\n      this.set([keyA, keyB], value);\n    }\n  }\n\n  private map = new Map<KeyA, Map<KeyB, Value>>();\n\n  clear(): void {\n    this.map.clear();\n  }\n\n  delete([keyA, keyB]: [KeyA, KeyB]): boolean {\n    return this.map.get(keyA)?.delete(keyB) || false;\n  }\n\n  clone(): KeyPairMap<KeyA, KeyB, Value> {\n    return new KeyPairMap(this);\n  }\n\n  forEach(\n    callbackfn: (\n      value: Value,\n      key: [KeyA, KeyB],\n      map: Map<[KeyA, KeyB], Value>\n    ) => void,\n    thisArg?: any\n  ): void {\n    const refMap = this.toRefMap();\n\n    refMap.forEach(callbackfn, thisArg);\n  }\n\n  private toRefMap() {\n    const tempMap = new Map<[KeyA, KeyB], Value>();\n    this.map.forEach((innerMap, keyA, outerMap) => {\n      innerMap.forEach((value, keyB, innerMap) => {\n        const keys = [keyA, keyB] as [KeyA, KeyB];\n        tempMap.set(keys, value);\n      });\n    });\n    return tempMap;\n  }\n\n  get([keyA, keyB]: [KeyA, KeyB]): Value | undefined {\n    return this.map.get(keyA)?.get(keyB);\n  }\n\n  has([keyA, keyB]: [KeyA, KeyB]): boolean {\n    return this.map.get(keyA)?.has(keyB) || false;\n  }\n\n  set([keyA, keyB]: [KeyA, KeyB], value: Value): this {\n    const hasKeyA = this.map.has(keyA);\n\n    if (!hasKeyA) {\n      this.map.set(keyA, new Map());\n    }\n    this.map.get(keyA)!.set(keyB, value);\n\n    return this;\n  }\n\n  get size() {\n    return this.toRefMap().size;\n  }\n\n  [Symbol.iterator](): IterableIterator<[[KeyA, KeyB], Value]> {\n    return this.toRefMap()[Symbol.iterator]();\n  }\n\n  entries(): IterableIterator<[[KeyA, KeyB], Value]> {\n    return this.toRefMap().entries();\n  }\n\n  keys(): IterableIterator<[KeyA, KeyB]> {\n    return this.toRefMap().keys();\n  }\n\n  values(): IterableIterator<Value> {\n    return this.toRefMap().values();\n  }\n\n  toString(): string {\n    let lines = [];\n\n    for (let [key, value] of this) {\n      lines.push(`${key[0]}, ${key[1]}, ${value}`);\n    }\n\n    return lines.join(\"\\n\");\n  }\n  [Symbol.toStringTag]: string;\n}\n","import { getRelativeClickPosition } from \"./getRelativeClickPosition\";\nimport { KeyPairMap } from \"./KeyPairMap\";\nimport { NoColor, RGBColor } from \"./RGBColor\";\nexport class PaintCanvas {\n  static DrawToCanvas(paintCanvas: PaintCanvas, canvas: HTMLCanvasElement) {\n    const context = canvas.getContext(\"2d\");\n    if (!context) throw new Error(\"Could not get context for canvas\");\n    paintCanvas.forEach(([x, y], color) => {\n      if (color === \"NO_COLOR\") {\n        context.clearRect(x, y, 1, 1);\n        return;\n      }\n\n      context.fillStyle = color.toHex();\n      context.fillRect(x, y, 1, 1);\n    });\n  }\n\n  static AreDimensionsCompatible(\n    paintCanvas: PaintCanvas,\n    canvas: HTMLCanvasElement\n  ) {\n    const { width, height } = canvas;\n    const dimension = paintCanvas.dimension();\n\n    if (width !== height) {\n      return false;\n    }\n\n    if (dimension !== width) {\n      return false;\n    }\n\n    return true;\n  }\n\n  drawToCanvas() {\n    if (this.canvas === undefined) {\n      throw new Error(\"Cannot draw to canvas, no canvas set\");\n    }\n\n    PaintCanvas.DrawToCanvas(this, this.canvas);\n  }\n\n  setCanvas(canvas: HTMLCanvasElement) {\n    if (!PaintCanvas.AreDimensionsCompatible(this, canvas)) {\n      throw new RangeError(\n        `PaintCanvas and HTMLCanvas should be square and the same dimensions. Got PaintCanvas: ${this.dimension()} canvas: ${\n          canvas.width\n        }x${canvas.height}`\n      );\n    }\n\n    this.canvas = canvas;\n  }\n\n  hasCanvas(): boolean {\n    return this.canvas !== undefined;\n  }\n\n  getCanvas(): HTMLCanvasElement | undefined {\n    return this.canvas;\n  }\n\n  private pixelMap = new KeyPairMap<number, number, RGBColor | NoColor>();\n\n  getPixelMap() {\n    return this.pixelMap;\n  }\n\n  setPixelMap(map: KeyPairMap<number, number, RGBColor | \"NO_COLOR\">) {\n    if (map.size !== this.pixelMap.size) {\n      throw new RangeError(\n        \"Cannot set pixel map. Pixel maps are not the same dimensions\"\n      );\n    }\n    this.pixelMap = map.clone();\n  }\n\n  setPixelsFromImage(image: HTMLImageElement) {\n    const canvas = document.createElement(\"canvas\");\n    const context = canvas.getContext(\"2d\");\n    if (!context) throw new Error(\"Could not get context for canvas\");\n\n    canvas.width = image.naturalWidth;\n    canvas.height = image.naturalHeight;\n    context.drawImage(image, 0, 0);\n\n    this.setPixelsFromCanvas(canvas);\n  }\n\n  setPixelsFromCanvas(canvas: HTMLCanvasElement) {\n    const context = canvas.getContext(\"2d\");\n    if (!context) throw new Error(\"Could not get context for canvas\");\n\n    const xIntervals = canvas.width / this.dimension();\n    const yIntervals = canvas.height / this.dimension();\n    this.mutableMap(([x, y]) => {\n      const { data } = context.getImageData(\n        x * xIntervals,\n        y * yIntervals,\n        1,\n        1\n      );\n\n      const [r, g, b, a] = data;\n      const color = a === 0 ? RGBColor.NO_COLOR : new RGBColor(r, g, b);\n      return color;\n    });\n  }\n\n  clear() {\n    this.mutableMap(() => RGBColor.NO_COLOR);\n  }\n\n  setColorAt(x: number, y: number, color: RGBColor | NoColor) {\n    const isPixelInRange = this.pixelMap.has([x, y]);\n\n    if (!isPixelInRange) {\n      throw RangeError(`Pixel at ${x},${y} does not exist`);\n    }\n\n    this.pixelMap.set([x, y], color);\n  }\n\n  getColorAt(x: number, y: number): RGBColor | NoColor {\n    const maybeColor = this.pixelMap.get([x, y]);\n\n    if (maybeColor === undefined)\n      throw RangeError(`Pixel at ${x},${y} does not exist`);\n\n    return maybeColor;\n  }\n\n  mutableMap(\n    callbackfn: (\n      coord: [x: number, y: number],\n      color: RGBColor | NoColor\n    ) => RGBColor | NoColor\n  ) {\n    for (let [key, value] of this.pixelMap.entries()) {\n      const result = callbackfn(key, value);\n      this.pixelMap.set(key, result);\n    }\n  }\n\n  forEach(\n    callbackfn: (\n      coord: [x: number, y: number],\n      color: RGBColor | NoColor\n    ) => void\n  ) {\n    for (let [key, value] of this.pixelMap.entries()) {\n      callbackfn(key, value);\n    }\n  }\n  private canvas?: HTMLCanvasElement;\n\n  constructor(dimension: number) {\n    for (let x = 0; x < dimension; x++) {\n      for (let y = 0; y < dimension; y++) {\n        const keys = [x, y] as [number, number];\n        const color = RGBColor.NO_COLOR;\n        this.pixelMap.set(keys, color);\n      }\n    }\n  }\n\n  dimension(): number {\n    return Math.sqrt(this.pixelMap.size);\n  }\n\n  touchEvent(event: React.TouchEvent<HTMLElement>, color: RGBColor | NoColor) {\n    const { relativeX, relativeY } = getRelativeClickPosition(event);\n    const scaledX = relativeX * this.dimension();\n    const scaledY = relativeY * this.dimension();\n    const quantX = Math.floor(scaledX);\n    const quantY = Math.floor(scaledY);\n\n    const currentColor = this.getColorAt(quantX, quantY);\n\n    if (color === \"NO_COLOR\" && currentColor === \"NO_COLOR\") {\n      return;\n    }\n\n    if (color === \"NO_COLOR\" && currentColor !== \"NO_COLOR\") {\n      this.setColorAt(quantX, quantY, color);\n      return;\n    }\n\n    if (color !== \"NO_COLOR\" && currentColor === \"NO_COLOR\") {\n      this.setColorAt(quantX, quantY, color);\n      return;\n    }\n\n    if (color !== \"NO_COLOR\" && currentColor !== \"NO_COLOR\") {\n      if (!RGBColor.Equals(color, currentColor)) {\n        this.setColorAt(quantX, quantY, color);\n      }\n    }\n  }\n}\n","import { UndoBuffer } from \"./UndoBuffer\";\n\nexport class UndoRedoBuffer<T> extends UndoBuffer<T> {\n  private redoBuffer = new Array<T>();\n\n  undo(): T {\n    const maybeTop = this.top();\n    if (maybeTop !== undefined && this.getBufferLength() > 1) {\n      this.redoBuffer.push(maybeTop);\n    }\n\n    const previousPoint = super.undo();\n    return previousPoint;\n  }\n\n  addCurrent(value: T) {\n    this.redoBuffer = [];\n    super.addCurrent(value);\n  }\n\n  getUndoSize() {\n    return super.getUndoSize();\n  }\n\n  getRedoSize() {\n    return this.redoBuffer.length;\n  }\n\n  redoOne(): T | undefined {\n    const redid = this.redoBuffer.pop();\n    if (redid !== undefined) {\n      super.addCurrent(redid);\n    }\n\n    return redid;\n  }\n\n  clear() {\n    this.redoBuffer = [];\n    super.clear();\n  }\n}\n","export class UndoBuffer<T> {\n  buffer: T[];\n\n  constructor(private base: T, private maxSize?: number) {\n    this.buffer = [base];\n  }\n\n  top() {\n    return this.buffer[this.buffer.length - 1] as T | undefined;\n  }\n\n  undo() {\n    this.buffer.pop();\n    const maybeReverseState = this.buffer[this.buffer.length - 1] as\n      | T\n      | undefined;\n    if (maybeReverseState) {\n      return maybeReverseState;\n    } else {\n      this.buffer = [this.base];\n      return this.base;\n    }\n  }\n\n  addCurrent(value: T) {\n    this.buffer.push(value);\n\n    if (this.maxSize && this.maxSize < this.buffer.length) {\n      this.buffer = this.buffer.slice(-this.maxSize - 2);\n    }\n  }\n\n  getUndoSize() {\n    return Math.max(this.buffer.length - 2, 0);\n  }\n\n  getBufferLength() {\n    return this.buffer.length;\n  }\n\n  clear() {\n    this.buffer = [];\n  }\n}\n","import { KeyPairMap } from \"./KeyPairMap\";\nimport { PaintCanvas } from \"./PaintCanvas\";\nimport { NoColor, RGBColor } from \"./RGBColor\";\nimport { UndoRedoBuffer } from \"./UndoRedoBuffer\";\n\nexport class UndoablePaintCanvas extends PaintCanvas {\n  undoBuffer: UndoRedoBuffer<KeyPairMap<number, number, RGBColor | \"NO_COLOR\">>;\n  constructor(dimension: number) {\n    super(dimension);\n\n    this.undoBuffer = new UndoRedoBuffer<\n      KeyPairMap<number, number, RGBColor | NoColor>\n    >(this.getPixelMap().clone());\n  }\n\n  mutableMap(\n    callbackfn: (\n      coord: [x: number, y: number],\n      color: RGBColor | NoColor\n    ) => RGBColor | NoColor\n  ) {\n    super.mutableMap(callbackfn);\n    this.undoBuffer.addCurrent(this.getPixelMap().clone());\n  }\n\n  setColorAt(x: number, y: number, color: RGBColor | NoColor) {\n    super.setColorAt(x, y, color);\n    this.undoBuffer.addCurrent(this.getPixelMap().clone());\n  }\n\n  undo() {\n    const undo = this.undoBuffer.undo();\n    this.setPixelMap(undo);\n  }\n\n  redo() {\n    const redo = this.undoBuffer.redoOne();\n    if (redo !== undefined) {\n      this.setPixelMap(redo);\n    }\n  }\n}\n","import React, { useMemo, useState } from \"react\";\nimport { CanvasContainer } from \"./components/CanvasContainer\";\nimport { ClearButton } from \"./components/ClearButton\";\nimport { ColorPickerHistory } from \"./components/ColorPickerHistory\";\nimport { ColorPickerSwatch } from \"./components/ColorPickerSwatch\";\nimport { CurrentColor } from \"./components/CurrentColor\";\nimport { DimensionPicker, ValidDimensions } from \"./components/DimensionPicker\";\nimport { Grid } from \"./components/Grid\";\nimport { LoadButton } from \"./components/LoadButton\";\nimport { SaveButton } from \"./components/SaveButton\";\nimport { ToggleButton } from \"./components/ToggleButton\";\nimport { RGBColor } from \"./drivers/RGBColor\";\nimport { UndoablePaintCanvas } from \"./drivers/UndoablePaintCanvas\";\nimport \"./styles/App.css\";\n\nfunction App() {\n  const [pixelDimensions, setPixelDimensions] = useState<ValidDimensions>(1);\n  const [color, setColor] = useState<RGBColor>(new RGBColor(0, 0, 0));\n  const [isGridShown, setGridShown] = useState(false);\n  const [isPickerShown, setPickerShown] = useState(false);\n  const [canvas, setCanvas] = useState<undefined | HTMLCanvasElement>();\n\n  const paint = useMemo(() => {\n    return new UndoablePaintCanvas(pixelDimensions);\n  }, [pixelDimensions]);\n\n  return (\n    <div className=\"App\">\n      {isPickerShown && (\n        <ColorPickerSwatch selectedColor={color} onColorPicked={setColor} />\n      )}\n      <CanvasContainer\n        onCanvasCreated={(canvas) => {\n          setCanvas(canvas);\n          paint.setCanvas(canvas);\n        }}\n        pixelDimensions={pixelDimensions}\n        onTouchEvent={(canvas, event) => {\n          paint.setCanvas(canvas);\n          paint.touchEvent(event, color);\n          paint.drawToCanvas();\n        }}\n      />\n      {canvas && isGridShown && (\n        <Grid pixelDimensions={pixelDimensions} rootCanvas={canvas} />\n      )}\n      <ColorPickerHistory onColorPicked={setColor} colorSelected={color} />\n      <CurrentColor color={color} />\n      <LoadButton\n        setLoadedImage={(image) => {\n          paint.setPixelsFromImage(image);\n          paint.drawToCanvas();\n        }}\n      />\n      {canvas && <SaveButton canvas={canvas} />}\n      <ClearButton\n        onClearPressed={() => {\n          paint.clear();\n          if (paint.hasCanvas()) {\n            paint.drawToCanvas();\n          } else {\n            console.warn(\"Tried to clear a canvas that doesn't exist\");\n          }\n        }}\n      />\n\n      <button\n        onTouchEnd={() => {\n          paint.undo();\n          paint.drawToCanvas();\n        }}\n      >\n        Undo\n      </button>\n      <button\n        onTouchEnd={() => {\n          paint.redo();\n          paint.drawToCanvas();\n        }}\n      >\n        Redo\n      </button>\n      <ToggleButton\n        onToggle={() => setGridShown(!isGridShown)}\n        text={isGridShown ? \"Hide Grid\" : \"Show Grid\"}\n      />\n      <ToggleButton\n        onToggle={() => setPickerShown(!isPickerShown)}\n        text={isPickerShown ? \"Hide Color Picker\" : \"Show Color Picker\"}\n      />\n      <DimensionPicker\n        onDimensionChange={setPixelDimensions}\n        dimension={pixelDimensions}\n      />\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./styles/index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}