{"version":3,"sources":["drivers/color/src/HSLColor.ts","drivers/color/src/RGBColor.ts","PaletteDictionary.ts","components/BodyColorPicker.tsx","components/CanvasContainer.tsx","components/Grid.tsx","components/CanvasStack.tsx","components/DropperIcon.tsx","components/PaletteIcon.tsx","components/HighlightableButton.tsx","components/ControlsBanner.tsx","hooks/useTimeout.tsx","components/ControlsFeedback.tsx","components/SaveButton.tsx","components/Footer.tsx","drivers/paint/src/KeyPairMap.ts","drivers/paint/src/PaintCanvas.ts","drivers/paint/src/getRelativeClickPosition.tsx","drivers/paint/src/UndoRedoBuffer.ts","drivers/paint/src/UndoBuffer.ts","drivers/paint/src/UndoablePaintCanvas.ts","modals/Modal.tsx","modals/ConfirmModal.tsx","components/DimensionPicker.tsx","components/LoadButton.tsx","modals/NewPageModal.tsx","components/PalettePicker.tsx","modals/PaletteModal.tsx","hooks/useLongPress.tsx","modals/BackgroundImageSettings.tsx","images/checker-board.png","modals/SettingsModal.tsx","App.tsx","index.tsx"],"names":["HSLColor","hue","saturation","lightness","hsl","this","hslString","sep","indexOf","substr","split","hString","s","parseFloat","length","l","h","Math","round","PI","r","g","b","cMin","min","cMax","max","delta","abs","RGBColor","fromHSL","red","green","blue","rgb","RangeError","c","x","m","hex","Number","isInteger","TypeError","hexString","toString","fromHexString","rgbString","rgbChunks","rgbValues","R","parseInt","rString","gString","bString","fromRGB","a","r1","g1","b1","r2","g2","b2","NO_COLOR","paletteColorDictionary","c64","cga","teletext","paletteNameDictionary","BodyColorPicker","setColorAndTurnOffPicker","color","pickerMode","pinnedColors","colorHistory","setColorHistory","palette","useEffect","filter","currentColor","Equals","newColorHistory","unshift","useAddToColorHistory","boxRef","useRef","colors","slice","map","Box","ref","direction","justify","wrap","overflow","index","pad","right","top","Button","primary","icon","Blank","onClick","toHex","style","borderRadius","CanvasContainer","onCanvasCreated","onTouchEvent","pixelDimensions","background","canvasRef","canvas","current","onInnerTouchEvent","event","backgroundStyle","useMemo","getBackgroundStyle","backgroundClass","getBackgroundClass","className","width","height","onTouchEnd","onTouchMove","type","backgroundSize","backgroundColor","backgroundImage","image","src","size","Grid","rootCanvas","mode","context","getContext","clearRect","strokeStyle","lineWidth","xIncrement","yIncrement","xIndex","moveTo","lineTo","stroke","yIndex","drawLines","xPosition","yPosition","fillStyle","beginPath","arc","fill","drawDots","display","clientWidth","clientHeight","CanvasStack","gridMode","onCanvasTouch","stackProps","useState","setCanvas","Stack","DropperIcon","props","StyledIcon","viewBox","a11yTitle","strokeWidth","d","PaletteIcon","xmlns","fillOpacity","cx","cy","HighlightableButton","isHighlighted","boxShadow","ControlsBanner","onToolChange","onPickerModeClick","onUndoClick","onRedoClick","onPaletteButtonClick","onGridButtonClick","onTrashClick","onControlsClick","tool","callBefore","callback","control","arg","columns","rows","areas","name","start","end","gap","bottom","gridArea","Brush","Erase","Paint","focusIndicator","History","Pin","Gallery","Undo","Redo","Trash","Apps","useTimeout","delay","id","setTimeout","clearTimeout","controlToFeedback","dropper","eraser","grid","history","paint","paletteColor","pinned","redo","undo","trash","ControlsFeedback","onClose","opacity","setOpacity","Layer","position","responsive","onClickOutside","modal","animation","horizontal","vertical","Text","SaveButton","anchorRef","onShareClick","fullScaleCanvas","drawToHigherResolutionCanvas","Promise","resolve","reject","toBlob","maybeBlob","Error","blob","document","location","protocol","undefined","navigator","share","files","Object","freeze","File","canShare","title","catch","error","console","debug","toDataURL","href","click","Share","download","createElement","imageSmoothingEnabled","drawImage","Footer","onAddButtonClicked","setSettingsMenuShown","left","count","align","Actions","Add","Symbol","iterator","toStringTag","KeyPairMap","keyPairMap","Map","keyA","keyB","value","set","clear","get","delete","callbackfn","thisArg","toRefMap","forEach","tempMap","innerMap","outerMap","keys","has","entries","values","lines","key","push","join","PaintCanvas","dimension","pixelMap","y","DrawToCanvas","drawToCanvas","AreDimensionsCompatible","clone","naturalWidth","naturalHeight","setPixelsFromCanvas","xIntervals","yIntervals","mutableMap","data","getImageData","maybeColor","results","Array","elementResult","result","paintCanvas","fillRect","sqrt","touch","target","touchToCoords","quantX","quantY","getColorAt","setColorAt","screenX","clientX","screenY","clientY","rect","getBoundingClientRect","clip","clippedX","clippedY","relativeX","relativeY","getRelativeClickPosition","scaledX","scaledY","floor","UndoRedoBuffer","redoBuffer","maybeTop","getBufferLength","redid","pop","base","maxSize","buffer","maybeReverseState","UndoablePaintCanvas","undoBuffer","cellExists","getPixelMap","addCurrent","setPixelMap","redoOne","fillColor","startColor","visited","floodFill","cellColor","AreColorsEqual","doesCellMatchFillColor","colorA","colorB","Modal","children","heading","full","Heading","alignSelf","level","margin","Close","ConfirmModal","onAccept","onCancel","message","cancelButtonText","acceptButtonText","label","labelToValue","valueToLabel","1","8","10","12","14","16","18","20","22","24","options","DimensionPicker","onDimensionChange","FormField","Select","placeholder","onChange","option","LoadButton","setLoadedImage","onLoadStart","input","imagePromise","imageUrl","URL","createObjectURL","Image","onload","accept","NewPageModal","currentDimension","onCreateNew","loadedImage","loading","setLoading","setDimension","promise","disabled","Teletext","PalettePicker","onPaletteChange","possiblePalettes","PaletteModal","setColor","setPinnedColors","setPalette","innerPalette","setInnerPalette","selectedPalette","onLongPressComplete","duration","onLongPressCancel","timeout","wasLongPress","cancelTimeout","onPressDown","onPressUp","useLongPress","getButtonIndex","find","currentPinnedColors","preventDefault","maybeIndex","onTouchStart","isPinned","data-index","border","maybeIndexString","dataset","backgroundTypes","BackgroundImageSettings","onSave","outerBackgroundData","setBackground","isPaletteModalShown","setPaletteMenuShown","fit","SettingsModal","setDarkMode","isDarkMode","isFeedbackOn","isBackgroundImageSettingsShown","setBackgroundImageSettingsShown","backgroundData","setBackgroundData","innerIsFeedbackOn","setFeedbackOn","CheckBox","toggle","checked","mergedTheme","deepMerge","grommet","medium","global","edgeSize","small","useStickyBrush","defaultBrush","setTool","brush","setBrush","useCallback","App","setPixelDimensions","confirmModalParameters","createModal","setToolAndBrush","setControl","setPickerMode","setGridShown","isControlsFeedbackModalShown","setControlsFeedbackModalShown","setDrawImage","isNewPageModalShown","setCreateMenuShown","isSettingsMenuShown","darkMode","setPixelsFromImage","isConfirmModalShown","Grommet","theme","themeMode","Header","interactiveChild","changedTouches","coords","selectedColor","touchEvent","fillWithColor","Main","elevation","maybeLoadedImage","settingsData","window","oncontextmenu","stopPropagation","ReactDOM","render","StrictMode","getElementById"],"mappings":"+SAEaA,EAAb,WAyEE,WAAYC,EAAaC,EAAoBC,GAAoB,yBAIjEC,SAJgE,EAC9DC,KAAKD,IAAM,CAACH,EAAKC,EAAYC,GA1EjC,+DAWuBG,GACnB,IAAIC,EAAMD,EAAUE,QAAQ,MAAQ,EAAI,IAAM,IACxCJ,EAAME,EAAUG,OAAO,GAAGC,MAAM,KAAK,GAAGA,MAAMH,GAEhDI,EAAUP,EAAI,GACdQ,EAAIC,WAAWT,EAAI,GAAGK,OAAO,EAAGL,EAAI,GAAGU,OAAS,IAAM,IACtDC,EAAIF,WAAWT,EAAI,GAAGK,OAAO,EAAGL,EAAI,GAAGU,OAAS,IAAM,IAEtDE,EAAI,EAaR,OAXIL,EAAQH,QAAQ,QAAU,EAC5BG,EAAUA,EAAQF,OAAO,EAAGE,EAAQG,OAAS,GACtCH,EAAQH,QAAQ,QAAU,EACjCQ,EAAIC,KAAKC,MACPL,WAAWF,EAAQF,OAAO,EAAGE,EAAQG,OAAS,KAAO,IAAMG,KAAKE,KAE3DR,EAAQH,QAAQ,SAAW,IAClCQ,EAAIC,KAAKC,MAA0D,IAApDL,WAAWF,EAAQF,OAAO,EAAGE,EAAQG,OAAS,MAE3DE,GAAK,MAAKA,GAAK,KAEZ,IAAIhB,EAASgB,EAAGJ,EAAGG,KAhC9B,8BAmCiBK,EAAWC,EAAWC,GAEnCF,GAAK,IACLC,GAAK,IACLC,GAAK,IAGL,IAKIP,EALAQ,EAAON,KAAKO,IAAIJ,EAAGC,EAAGC,GACtBG,EAAOR,KAAKS,IAAIN,EAAGC,EAAGC,GACtBK,EAAQF,EAAOF,EACfP,EAAI,EAyBR,OAnBiBA,EAAH,IAAVW,EAAiB,EAEZF,IAASL,GAASC,EAAIC,GAAKK,EAAS,EAEpCF,IAASJ,GAAQC,EAAIF,GAAKO,EAAQ,GAEjCP,EAAIC,GAAKM,EAAQ,GAE3BX,EAAIC,KAAKC,MAAU,GAAJF,IAGP,IAAGA,GAAK,KAGhBD,GAAKU,EAAOF,GAAQ,EAKb,IAAIvB,EAASgB,EAFN,IAAVW,EAAc,EAAIA,GAAS,EAAIV,KAAKW,IAAI,EAAIb,EAAI,IAE1BA,OAtE9B,mDAmGiB,IAAD,cACMV,KAAKD,IADX,GAEZ,MAAO,OAFK,KAEQ,IAAU,IAFlB,KAEwB,KAAW,IAFnC,KAEyC,OArGzD,8BAyGI,OAAOyB,EAASC,QAAT,MAAAD,EAAQ,YAAYxB,KAAKD,QAzGpC,8BA6GI,OAAO,YAAIJ,EAAX,YAAuBK,KAAKD,QA7GhC,wBAgFI,OAAOC,KAAKD,IAAI,IAhFpB,aAyFQY,GACJX,KAAKD,IAAI,GAAKY,IA1FlB,wBAmFI,OAAOX,KAAKD,IAAI,IAnFpB,aA4FQQ,GACJP,KAAKD,IAAI,GAAKQ,IA7FlB,wBAsFI,OAAOP,KAAKD,IAAI,IAtFpB,aA+FQW,GACJV,KAAKD,IAAI,GAAKW,MAhGlB,KCCac,EAAb,WAmHE,WAAYE,EAAaC,EAAeC,GAAe,yBAIvDC,SAJsD,EACpD7B,KAAK6B,IAAM,CAACH,EAAKC,EAAOC,GApH5B,yDAOiBjB,EAAWJ,EAAWG,GACnC,GAAIC,EAAI,GAAKA,EAAI,IACf,MAAM,IAAImB,WAAW,6CAEvB,GAAIvB,EAAI,GAAKA,EAAI,EACf,MAAM,IAAIuB,WACR,sEAGJ,GAAIpB,EAAI,GAAKA,EAAI,EACf,MAAM,IAAIoB,WACR,qEAIJ,IAAIC,GAAK,EAAInB,KAAKW,IAAI,EAAIb,EAAI,IAAMH,EAChCyB,EAAID,GAAK,EAAInB,KAAKW,IAAMZ,EAAI,GAAM,EAAK,IACvCsB,EAAIvB,EAAIqB,EAAI,EACZhB,EAAI,EACJC,EAAI,EACJC,EAAI,EA+BR,OA7BI,GAAKN,GAAKA,EAAI,IAChBI,EAAIgB,EACJf,EAAIgB,EACJf,EAAI,GACK,IAAMN,GAAKA,EAAI,KACxBI,EAAIiB,EACJhB,EAAIe,EACJd,EAAI,GACK,KAAON,GAAKA,EAAI,KACzBI,EAAI,EACJC,EAAIe,EACJd,EAAIe,GACK,KAAOrB,GAAKA,EAAI,KACzBI,EAAI,EACJC,EAAIgB,EACJf,EAAIc,GACK,KAAOpB,GAAKA,EAAI,KACzBI,EAAIiB,EACJhB,EAAI,EACJC,EAAIc,GACK,KAAOpB,GAAKA,EAAI,MACzBI,EAAIgB,EACJf,EAAI,EACJC,EAAIe,GAMC,IAAIR,EAJXT,EAAIH,KAAKC,MAAgB,KAATE,EAAIkB,IACpBjB,EAAIJ,KAAKC,MAAgB,KAATG,EAAIiB,IACpBhB,EAAIL,KAAKC,MAAgB,KAATI,EAAIgB,OAxDxB,8BAgEiBC,GACb,IAAKC,OAAOC,UAAUF,GACpB,MAAM,IAAIG,UAAJ,4CAAmDH,IAC3D,GAAIA,EAAM,GAAKA,EAAG,GAChB,MAAM,IAAIJ,WAAW,iDAGvB,IAAMQ,EAAYJ,EAAIK,SAAS,IAE/B,OAAOf,EAASgB,cAAc,IAAMF,KAzExC,oCA4EuBG,GACnB,IAAIvC,EAAMuC,EAAUtC,QAAQ,MAAQ,EAAI,IAAM,IACxCuC,EAAYD,EAAUrC,OAAO,GAAGC,MAAM,KAAK,GAAGA,MAAMH,GACpDyC,EAAsB,GAE5B,IAAK,IAAIC,KAAKF,EAAW,CACvB,IAAI3B,EAAI2B,EAAUE,GACd7B,EAAEZ,QAAQ,MAAQ,IACpBwC,EAAUC,GACkD,IAA1DhC,KAAKC,MAAML,WAAWO,EAAEX,OAAO,EAAGW,EAAEN,OAAS,IAAM,MAOzD,OAAO,IAAIe,EAJDmB,EAAU,GACVA,EAAU,GACVA,EAAU,MA1FxB,oCA+FuBL,GACnB,GAAyB,IAArBA,EAAU7B,OACZ,MAAM,IAAI4B,UACR,6CAA+CC,GAInD,GAAqB,MAAjBA,EAAU,GACZ,MAAM,IAAID,UACR,8CAAgDC,EAAU,IAQ9D,OAAO,IAAId,EAJDqB,SAAS,KAAOP,EAAU,GAAKA,EAAU,GAAI,IAC7CO,SAAS,KAAOP,EAAU,GAAKA,EAAU,GAAI,IAC7CO,SAAS,KAAOP,EAAU,GAAKA,EAAU,GAAI,SA9G3D,6CAoJW,IAAD,cACYtC,KAAK6B,IADjB,GACCd,EADD,KACIC,EADJ,KACOC,EADP,KAEF6B,EAAU/B,EAAEwB,SAAS,IACrBQ,EAAU/B,EAAEuB,SAAS,IACrBS,EAAU/B,EAAEsB,SAAS,IASzB,OAPuB,IAAnBO,EAAQrC,SACVqC,EAAU,IAAMA,GACK,IAAnBC,EAAQtC,SACVsC,EAAU,IAAMA,GACK,IAAnBC,EAAQvC,SACVuC,EAAU,IAAMA,GAEX,IAAMF,EAAUC,EAAUC,IAjKrC,8BAqKI,OAAOrD,EAASsD,QAAT,MAAAtD,EAAQ,YAAYK,KAAK6B,QArKpC,wBA0HI,OAAO7B,KAAK6B,IAAI,IA1HpB,aAmIQd,GACJf,KAAK6B,IAAI,GAAKd,IApIlB,wBA6HI,OAAOf,KAAK6B,IAAI,IA7HpB,aAsIQb,GACJhB,KAAK6B,IAAI,GAAKb,IAvIlB,wBAgII,OAAOhB,KAAK6B,IAAI,IAhIpB,aAyIQZ,GACJjB,KAAK6B,IAAI,GAAKZ,KA1IlB,8BA6IgBiC,EAAajC,GAAc,IAAD,cACjBiC,EAAErB,IADe,GAC/BsB,EAD+B,KAC3BC,EAD2B,KACvBC,EADuB,mBAEjBpC,EAAEY,IAFe,GAE/ByB,EAF+B,KAE3BC,EAF2B,KAEvBC,EAFuB,KAItC,OAAOL,IAAOG,GAAMF,IAAOG,GAAMF,IAAOG,MAjJ5C,KAAahC,EACKiC,SAAoB,WCJ/B,IAAMC,EAET,CACFC,IAAK,CACH,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WAEFC,IAAK,CACH,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WAEFC,SAAU,CACR,UACA,UACA,UACA,UACA,UACA,UACA,UACA,YAISC,EAAwB,CACnCH,IAAK,eACLC,IAAK,eACLC,SAAU,YC7CCE,EAAkB,SAAC,GAgBzB,IAfLC,EAeI,EAfJA,yBACAC,EAcI,EAdJA,MACAC,EAaI,EAbJA,WACAC,EAYI,EAZJA,aACAC,EAWI,EAXJA,aACAC,EAUI,EAVJA,gBACAC,EASI,EATJA,SA6CF,SACEF,EACAH,EACAI,GAEAE,qBAAU,WACR,GAGgB,IAFdH,EAAaI,QAAO,SAACC,GACnB,OAAOjD,EAASkD,OAAOD,EAAcR,MACpCxD,OAHL,CAQA,IAAIkE,EAAe,YAAOP,GAC1BO,EAAgBC,QAAQX,GAExBI,EAAgBM,MAEf,CAACV,IAtDJY,CAAqBT,EAAcH,EAAOI,GAE1C,IAAMS,EAASC,iBAAuB,MAClCC,EAAqB,GAEzB,OAAQd,GACN,IAAK,UACHc,EAASZ,EAAaa,MAAM,EAAG,IAC/B,MACF,IAAK,SACHD,EAASb,EACT,MACF,IAAK,UACHa,EAAStB,EAAuBY,GAASY,KAAI,SAACjB,GAAD,OAC3CzC,EAASgB,cAAcyB,MAI7B,OACE,cAACkB,EAAA,EAAD,CAAKC,IAAKN,EAAQO,UAAU,MAAMC,QAAQ,UAAUC,MAAI,EAACC,SAAS,OAAlE,SACGR,EAAOE,KAAI,SAACjB,EAAOwB,GAAR,OACV,cAACN,EAAA,EAAD,CAAKO,IAAK,CAAEC,MAAO,UAAWC,IAAK,WAAnC,SACE,cAACC,EAAA,EAAD,CACEC,SAAO,EACPC,KAAM,cAACC,EAAA,EAAD,IACNC,QAAS,kBAAMjC,EAAyBC,IACxCA,MAAOA,EAAMiC,QACbC,MAAO,CAAEC,aAAc,MAN0BX,S,oBC3ChDY,G,MAAkB,SAAC,GAazB,IAZLC,EAYI,EAZJA,gBACAC,EAWI,EAXJA,aACAC,EAUI,EAVJA,gBACAC,EASI,EATJA,WAUMC,EAAY3B,iBAA0B,MAE5CR,qBAAU,WACR,IAAMoC,EAASD,EAAUE,QACrBD,GACFL,EAAgBK,KAEjB,CAACL,IAEJ,IAAMO,EAAoB,SAACC,GACzB,IAAMH,EAASD,EAAUE,QACpBD,GACLJ,EAAaI,EAAQG,IAGjBC,EAAkBC,mBACtB,kBAAMC,EAAmBR,EAAYD,KACrC,CAACC,EAAYD,IAETU,EAAkBF,mBAAQ,kBAAMG,EAAmBV,KAAa,CACpEA,IAGF,OACE,wBACEW,UAAS,0BAAqBF,GAC9Bf,MAAOY,EACP3B,IAAKsB,EACLW,MAAOb,EACPc,OAAQd,EACRe,WAAYV,EACZW,YAAaX,MAKbM,EAAqB,SAACV,GAC1B,OAAQA,EAAWgB,MACjB,IAAK,eACH,MAAO,yBACT,IAAK,QACH,MAAO,kBACT,IAAK,QACH,MAAO,oBAIPR,EAAqB,SACzBR,EACAD,GACI,IAAD,EACH,OAAQC,EAAWgB,MACjB,IAAK,eACH,MAAO,CACLC,eAAe,GAAD,OAAK,IAAMlB,EAAkB,EAA7B,MAElB,IAAK,QACH,MAAO,CACLmB,gBAAiBlB,EAAWxC,MAAMiC,SAEtC,IAAK,QACH,MAAO,CACLyB,gBAAiBlB,EAAWxC,MAAMiC,QAClC0B,gBAAgB,OAAD,iBAASnB,EAAWoB,aAApB,aAAS,EAAkBC,IAA3B,KACfJ,eAAgBjB,EAAWsB,QC9EtBC,G,MAAO,SAAC,GAQd,IAPLxB,EAOI,EAPJA,gBACAyB,EAMI,EANJA,WACAC,EAKI,EALJA,KAMMxB,EAAY3B,iBAA0B,MA0B5C,OAxBAR,qBAAU,WACR,GAAK2D,EAAL,CACA,IAAMvB,EAASD,EAAUE,QACnBuB,EAAO,OAAGxB,QAAH,IAAGA,OAAH,EAAGA,EAAQyB,WAAW,MAEnC,GAAKD,GAAYxB,EAAjB,CAEAwB,EAAQE,UAAU,EAAG,EAAG1B,EAAOU,MAAOV,EAAOW,QAC7Ca,EAAQG,YAAc,YACtBH,EAAQI,UAAY,EACpB,IAAMC,EAAa7B,EAAOU,MAAQb,EAC5BiC,EAAa9B,EAAOW,OAASd,EAQnC,MANa,UAAT0B,EAwCR,SACEC,EACAK,EACAC,EACAjC,GAEA,IAAK,IAAIkC,EAAS,EAAGA,EAASlC,EAAiBkC,IAC7CP,EAAQQ,OAAO/H,KAAKC,MAAM6H,EAASF,GAAa,GAChDL,EAAQS,OAAOhI,KAAKC,MAAM6H,EAASF,GAAaL,EAAQxB,OAAOW,QAC/Da,EAAQU,SAIV,IAAK,IAAIC,EAAS,EAAGA,EAAStC,EAAiBsC,IAC7CX,EAAQQ,OAAO,EAAG/H,KAAKC,MAAMiI,EAASL,IACtCN,EAAQS,OAAOT,EAAQxB,OAAOU,MAAOzG,KAAKC,MAAMiI,EAASL,IACzDN,EAAQU,SAvDNE,CAAUZ,EAASK,EAAYC,EAAYjC,GAqBjD,SACE2B,EACAK,EACAC,EACAjC,GAEA,IAAK,IAAIkC,EAAS,EAAGA,GAAUlC,EAAiBkC,IAC9C,IAAK,IAAII,EAAS,EAAGA,GAAUtC,EAAiBsC,IAAU,CACxD,IAAME,EAAYR,EAAaE,EACzBO,EAAYR,EAAaK,EAC/BX,EAAQe,UAAY,YACpBf,EAAQgB,YACRhB,EAAQiB,IAAIJ,EAAWC,EAAW,EAAG,EAAa,EAAVrI,KAAKE,IAAQ,GACrDqH,EAAQkB,QAhCRC,CAASnB,EAASK,EAAYC,EAAYjC,GAGrC,WACL2B,EAAQE,UAAU,EAAG,EAAG1B,EAAOU,MAAOV,EAAOW,cAK/C,wBACEnB,MAAO,CAAEoD,QAAkB,QAATrB,EAAiB,OAAS,SAC5C9C,IAAKsB,EAELU,UAAU,OACVC,MAAOY,EAAWuB,YAClBlC,OAAQW,EAAWwB,cAHdjD,KCrCJ,IAAMkD,EAAc,SAAC,GAiBrB,IAhBLC,EAgBI,EAhBJA,SACAnD,EAeI,EAfJA,gBACAC,EAcI,EAdJA,WACAH,EAaI,EAbJA,gBACAsD,EAYI,EAZJA,cACAC,EAWI,EAXJA,WAWI,EACwBC,qBADxB,mBACGnD,EADH,KACWoD,EADX,KAEJ,OACE,eAACC,EAAA,EAAD,2BAAWH,GAAX,cACE,cAAC,EAAD,CACEvD,gBAAiB,SAACK,GAChBoD,EAAUpD,GACVL,EAAgBK,IAElBF,WAAYA,EACZD,gBAAiBA,EACjBD,aAAcqD,IAGfjD,GACC,cAAC,EAAD,CACEH,gBAAiBA,EACjByB,WAAYtB,EACZuB,KAAMyB,S,2GCtCHM,EAAc,SAACC,GAAD,OACzB,cAACC,EAAA,WAAD,yBAAYC,QAAQ,gBAAgBC,UAAU,WAAcH,GAA5D,aACE,oBAAGb,KAAK,OAAOR,OAAO,OAAOyB,YAAY,SAAzC,UACE,sBAAMC,EAAE,kZACR,sBAAMA,EAAE,wCCJDC,EAAc,SAACN,GAAD,OACzB,eAACC,EAAA,WAAD,yBAAYC,QAAQ,gBAAgBC,UAAU,WAAcH,GAA5D,cACE,sBACEO,MAAM,6BACNF,EAAE,yRACFG,YAAY,IACZJ,YAAY,WAEd,wBAAQK,GAAG,SAASC,GAAG,SAAS7J,EAAE,YAAY8H,OAAO,SACrD,wBAAQ8B,GAAG,SAASC,GAAG,SAAS7J,EAAE,YAAY8H,OAAO,SACrD,wBAAQ8B,GAAG,SAASC,GAAG,SAAS7J,EAAE,YAAY8H,OAAO,SACrD,wBAAQ8B,GAAG,SAASC,GAAG,SAAS7J,EAAE,YAAY8H,OAAO,c,QCb5CgC,EAAsB,SAAC,GAQkB,IAPpD5E,EAOmD,EAPnDA,QACA6E,EAMmD,EANnDA,cACGZ,EAKgD,2CACnD,OACE,cAACrE,EAAA,EAAD,aACEI,QAASA,EACTE,MAAO,CACLC,aAAc,OACd2E,UAAWD,EAAgB,yBAA2B,SAEpDZ,KCIGc,EAAiB,SAAC,GA0BxB,IAzBLC,EAyBI,EAzBJA,aACAC,EAwBI,EAxBJA,kBACAC,EAuBI,EAvBJA,YACAC,EAsBI,EAtBJA,YACAC,EAqBI,EArBJA,qBACAC,EAoBI,EApBJA,kBACAC,EAmBI,EAnBJA,aACAC,EAkBI,EAlBJA,gBACA7B,EAiBI,EAjBJA,SACA1F,EAgBI,EAhBJA,MACAC,EAeI,EAfJA,WACAuH,EAcI,EAdJA,KAeMC,EAAa,SACjBC,EACAC,GAEA,OAAO,SAACC,GACNL,EAAgBI,GACZC,EACFF,EAASE,GAETF,MAKN,OACE,eAAC,IAAD,CACEtC,KAAM,aACNyC,QAAS,CAAC,OAAQ,QAClBC,KAAM,CAAC,OAAQ,QACfC,MAAO,CACL,CAAEC,KAAM,WAAYC,MAAO,CAAC,EAAG,GAAIC,IAAK,CAAC,EAAG,IAC5C,CAAEF,KAAM,WAAYC,MAAO,CAAC,EAAG,GAAIC,IAAK,CAAC,EAAG,IAC5C,CAAEF,KAAM,YAAaC,MAAO,CAAC,EAAG,GAAIC,IAAK,CAAC,EAAG,IAC7C,CAAEF,KAAM,YAAaC,MAAO,CAAC,EAAG,GAAIC,IAAK,CAAC,EAAG,KAE/CC,IAAI,SACJ1G,IAAK,CAAE2G,OAAQ,SAXjB,UAaE,eAAClH,EAAA,EAAD,CAAKmH,SAAS,WAAWjH,UAAU,MAAM+G,IAAI,SAA7C,UACE,cAAC,EAAD,CACEtG,SAAO,EACPG,QAASyF,GAAW,kBAAMT,EAAa,WAAU,SACjDH,cAAwB,UAATW,EACf1F,KAAM,cAACwG,EAAA,EAAD,IACNtI,MAAOA,EAAMiC,UAEf,cAAC,EAAD,CACED,QAASyF,GAAW,kBAAMT,EAAa,YAAW,UAClDH,cAAwB,WAATW,EACf1F,KAAM,cAACyG,EAAA,EAAD,MAER,cAAC,EAAD,CACE1G,SAAO,EACPG,QAASyF,GAAW,kBAAMT,EAAa,UAAS,QAChDH,cAAwB,SAATW,EACf1F,KAAM,cAAC0G,EAAA,EAAD,IACNxI,MAAOA,EAAMiC,UAEf,cAACL,EAAA,EAAD,CACEI,QAASyF,EAAWL,EAAsB,WAC1CtF,KAAM,cAAC,EAAD,IACN2G,gBAAgB,IAElB,cAAC,EAAD,CACEzG,QAASyF,GAAW,kBAAMT,EAAa,aAAY,WACnDH,cAAwB,YAATW,EACf1F,KAAM,cAAC,EAAD,SAGV,eAACZ,EAAA,EAAD,CAAKmH,SAAS,WAAWjH,UAAU,MAAM+G,IAAI,SAA7C,UACE,cAAC,EAAD,CACErG,KAAM,cAAC4G,EAAA,EAAD,IACN1G,QAASyF,GAAW,kBAAMR,EAAkB,aAAY,WACxDJ,cAA8B,YAAf5G,IAEjB,cAAC,EAAD,CACE6B,KAAM,cAAC6G,EAAA,EAAD,IACN3G,QAASyF,GAAW,kBAAMR,EAAkB,YAAW,UACvDJ,cAA8B,WAAf5G,IAGjB,cAAC,EAAD,CACE6B,KAAM,cAAC8G,EAAA,EAAD,IACN5G,QAASyF,GACP,kBAAMR,EAAkB,aACxB,gBAEFJ,cAA8B,YAAf5G,OAGnB,eAACiB,EAAA,EAAD,CAAKmH,SAAS,YAAYjH,UAAU,MAAMC,QAAQ,MAAM8G,IAAI,SAA5D,UACE,cAACvG,EAAA,EAAD,CACEkC,KAAK,QACLhC,KAAM,cAAC+G,EAAA,EAAD,IACN7G,QAASyF,EAAWP,EAAa,QACjCuB,gBAAgB,IAElB,cAAC7G,EAAA,EAAD,CACEE,KAAM,cAACgH,EAAA,EAAD,IACN9G,QAASyF,EAAWN,EAAa,QACjCsB,gBAAgB,OAGpB,eAACvH,EAAA,EAAD,CAAKmH,SAAS,YAAYjH,UAAU,MAAMC,QAAQ,MAAM8G,IAAI,SAA5D,UACE,cAACvG,EAAA,EAAD,CACEI,QAASyF,EAAWH,EAAc,SAClCxF,KAAM,cAACiH,EAAA,EAAD,IACNN,gBAAgB,IAElB,cAAC,EAAD,CACEzG,QAASyF,EAAWJ,EAAmB,QACvCR,cAA4B,QAAbnB,EACf5D,KAAmB,SAAb4D,EAAsB,cAACsD,EAAA,EAAD,IAAW,cAAC,IAAD,a,kBCpJpCC,G,MAAa,SAACvB,EAAoBwB,GAC7C5I,qBAAU,WACR,IAAM6I,EAAKC,WAAW1B,EAAUwB,GAChC,OAAO,kBAAMG,aAAaF,MACzB,CAACzB,EAAUwB,MCAVI,GAA8C,CAClDC,QAAS,UACTC,OAAQ,SACRpE,KAAM,OACNqE,KAAM,OACNC,QAAS,gBACTC,MAAO,cACPC,aAAc,iBACdvJ,QAAS,UACTwJ,OAAQ,gBACRC,KAAM,OACNC,KAAM,OACNC,MAAO,gBAEIC,GAAmB,SAAC,GAM1B,IALLC,EAKI,EALJA,QACAvC,EAII,EAJJA,QAII,EAC0B9B,mBAAS,GADnC,mBACGsE,EADH,KACYC,EADZ,KAIJ,OAFAnB,EAAWiB,EAAS,KACpBjB,GAAW,kBAAMmB,EAAW,KAAI,KAE9B,cAACC,EAAA,EAAD,CACEC,SAAS,SACTC,YAAY,EACZC,eAAgBN,EAChBO,OAAO,EACPC,UAAU,OACVvH,UAAU,mBACVjB,MAAO,CAAEiI,UAASzG,gBAAiB,4BAPrC,SASE,cAACxC,EAAA,EAAD,CAAKO,IAAK,CAAEkJ,WAAY,QAASC,SAAU,UAA3C,SACE,cAACC,EAAA,EAAD,CAAM3I,MAAO,CAAElC,MAAO,SAAtB,SAAkCsJ,GAAkB3B,U,2DCpC/CmD,GAAa,SAAC,GAA+C,IAA7CpI,EAA4C,EAA5CA,OACrBqI,EAAYjK,iBAA0B,MACtCkK,EAAY,yCAAG,WAAOnI,GAAP,sBAAA5D,EAAA,6DACbgM,EAAkBC,GAA6BxI,GADlC,kBAIE,IAAIyI,SAAc,SAACC,EAASC,GAC7CJ,EAAgBK,QAAO,SAACC,GAClBA,EACFH,EAAQG,GAERF,EAAO,IAAIG,MAAM,uCAElB,gBAXY,UAIXC,EAJW,OAckB,WAA/BC,SAASC,SAASC,SAdL,sBAeT,IAAIJ,MAAM,uCAfD,eAkBOK,IAApBC,UAAUC,MAlBG,sBAmBT,IAAIP,MAAM,qCAnBD,UAsBXQ,EAAQC,OAAOC,OAAO,CAC1B,IAAIC,KAAK,CAACV,GAAO,mBAAoB,CAAEjI,KAAMiI,EAAKjI,SAG9CsI,UAAUM,UAAYN,UAAUM,SAAS,CAAEJ,UA1BhC,uBA2BT,IAAIR,MAAM,4CA3BD,yBA8BXM,UACHC,MAAM,CACLM,MAAO,eACPL,UAEDM,OAAM,SAACC,GACN,GAAmB,eAAfA,EAAMvE,KAIV,MAAMuE,EAHJC,QAAQC,MAAM,2BArCH,0DA2CjBD,QAAQC,MAAM,iDACdD,QAAQC,MAAR,MACM7I,EAAQqH,EAAgByB,UAAU,aACpC3B,EAAUpI,UACZoI,EAAUpI,QAAQgK,KAAO/I,EACzBmH,EAAUpI,QAAQiK,SAhDH,0DAAH,sDAoDlB,OACE,qCACE,cAAChL,EAAA,EAAD,CAAQE,KAAM,cAAC+K,GAAA,EAAD,IAAW7K,QAASgJ,EAAcvC,gBAAgB,IAChE,mBACEtH,IAAK4J,EACL4B,KAAK,IACLzK,MAAO,CAAEoD,QAAS,QAClBwH,SAAS,yBAMjB,SAAS5B,GAA6BxI,GACpC,IAAMuI,EAAkBS,SAASqB,cAAc,UAC/C9B,EAAgB7H,MAAQ,KACxB6H,EAAgB5H,OAAS,KACzB,IAAMa,EAAU+G,EAAgB9G,WAAW,MAS3C,OARAD,EAAQ8I,uBAAwB,EAChC9I,EAAQ+I,UACNvK,EACA,EACA,EACAuI,EAAgB7H,MAChB6H,EAAgB5H,QAEX4H,EClFF,I,MAAMiC,GAAS,SAAC,GASO,IAR5BxK,EAQ2B,EAR3BA,OACAyK,EAO2B,EAP3BA,mBACAC,EAM2B,EAN3BA,qBACA/E,EAK2B,EAL3BA,SAMA,OACE,cAACnH,EAAA,EAAD,CAAKmH,SAAUA,EAAU5G,IAAK,CAAE4L,KAAM,QAAS3L,MAAO,SAAtD,SACE,eAAC,IAAD,CACEmG,QAAS,CACPyF,MAAO,EACPxJ,KAAM,CAAC,OAAQ,OAAQ,SAEzBsB,MAAI,EACJ+C,IAAI,QANN,UAQE,cAACjH,EAAA,EAAD,CAAKqM,MAAM,QAAX,SACE,cAAC3L,EAAA,EAAD,CACEE,KAAM,cAAC0L,GAAA,EAAD,IACNxL,QAAS,kBAAMoL,GAAqB,IACpC3E,gBAAgB,MAGpB,cAACvH,EAAA,EAAD,CAAKqM,MAAM,SAAX,SACE,cAAC3L,EAAA,EAAD,CACEE,KAAM,cAAC2L,GAAA,EAAD,IACNzL,QAASmL,EACT1E,gBAAgB,MAGpB,cAACvH,EAAA,EAAD,CAAKqM,MAAM,MAAX,SAAkB,cAAC,GAAD,CAAY7K,OAAQA,Y,gDCmC3CgL,OAAOC,S,GAyBPD,OAAOE,YAhGH,IAAMC,GAAb,WACE,WAAYC,GACV,GADuD,yBASjD7M,IAAM,IAAI8M,IATsC,gBACjDD,EAAL,CADsD,qBAIpBA,GAJoB,IAItD,2BAA8C,CAAC,IAAD,+CAAnCE,EAAmC,KAA7BC,EAA6B,KAAtBC,EAAsB,KAC5CnS,KAAKoS,IAAI,CAACH,EAAMC,GAAOC,IAL6B,gCAD1D,oDAaInS,KAAKkF,IAAImN,UAbb,gCAgB+C,IAAD,qBAApCJ,EAAoC,KAA9BC,EAA8B,KAC1C,OAAO,UAAAlS,KAAKkF,IAAIoN,IAAIL,UAAb,eAAoBM,OAAOL,MAAS,IAjB/C,8BAqBI,OAAO,IAAIJ,EAAW9R,QArB1B,8BAyBIwS,EAKAC,GAEezS,KAAK0S,WAEbC,QAAQH,EAAYC,KAlC/B,iCAsCI,IAAMG,EAAU,IAAIZ,IAOpB,OANAhS,KAAKkF,IAAIyN,SAAQ,SAACE,EAAUZ,EAAMa,GAChCD,EAASF,SAAQ,SAACR,EAAOD,EAAMW,GAC7B,IAAME,EAAO,CAACd,EAAMC,GACpBU,EAAQR,IAAIW,EAAMZ,SAGfS,IA7CX,6BAgDsD,IAAD,qBAA9CX,EAA8C,KAAxCC,EAAwC,KACjD,iBAAOlS,KAAKkF,IAAIoN,IAAIL,UAApB,aAAO,EAAoBK,IAAIJ,KAjDnC,6BAoD4C,IAAD,qBAApCD,EAAoC,KAA9BC,EAA8B,KACvC,OAAO,UAAAlS,KAAKkF,IAAIoN,IAAIL,UAAb,eAAoBe,IAAId,MAAS,IArD5C,4BAwDkCC,GAAqB,IAAD,mBAA/CF,EAA+C,KAAzCC,EAAyC,KAQlD,OAPgBlS,KAAKkF,IAAI8N,IAAIf,IAG3BjS,KAAKkF,IAAIkN,IAAIH,EAAM,IAAID,KAEzBhS,KAAKkF,IAAIoN,IAAIL,GAAOG,IAAIF,EAAMC,GAEvBnS,OAhEX,yBAwEI,OAAOA,KAAK0S,WAAWf,OAAOC,cAxElC,gCA4EI,OAAO5R,KAAK0S,WAAWO,YA5E3B,6BAgFI,OAAOjT,KAAK0S,WAAWK,SAhF3B,+BAoFI,OAAO/S,KAAK0S,WAAWQ,WApF3B,iCAwFI,IADiB,EACbC,EAAQ,GADK,eAGQnT,MAHR,IAGjB,2BAA+B,CAAC,IAAD,yBAArBoT,EAAqB,KAAhBjB,EAAgB,KAC7BgB,EAAME,KAAN,UAAcD,EAAI,GAAlB,aAAyBA,EAAI,GAA7B,aAAoCjB,KAJrB,8BAOjB,OAAOgB,EAAMG,KAAK,QA9FtB,2BAoEI,OAAOtT,KAAK0S,WAAW3K,SApE3B,KCGO,IAAMwL,GAAb,WAgLE,WAAYC,GAAoB,yBA1GxBC,SAAW,IAAI3B,GA0GQ,KAFvBnL,YAEuB,EAC7B,IAAK,IAAI3E,EAAI,EAAGA,EAAIwR,EAAWxR,IAC7B,IAAK,IAAI0R,EAAI,EAAGA,EAAIF,EAAWE,IAAK,CAClC,IAAMX,EAAO,CAAC/Q,EAAG0R,GACXzP,EAAQzC,EAASiC,SACvBzD,KAAKyT,SAASrB,IAAIW,EAAM9O,IArLhC,2DAkCI,QAAoB6L,IAAhB9P,KAAK2G,OACP,MAAM,IAAI8I,MAAM,wCAGlB8D,EAAYI,aAAa3T,KAAMA,KAAK2G,UAtCxC,wCA0CI,IAEE,OADA3G,KAAK4T,gBACE,EACP,SACA,OAAO,KA9Cb,gCAkDYjN,GACR,IAAK4M,EAAYM,wBAAwB7T,KAAM2G,GAC7C,MAAM,IAAI7E,WAAJ,gGACqF9B,KAAKwT,YAD1F,oBAEF7M,EAAOU,MAFL,YAGAV,EAAOW,SAIftH,KAAK2G,OAASA,IA3DlB,kCA+DI,YAAuBmJ,IAAhB9P,KAAK2G,SA/DhB,kCAmEI,OAAO3G,KAAK2G,SAnEhB,oCAyEI,OAAO3G,KAAKyT,WAzEhB,kCA4EcvO,GACV,GAAIA,EAAI6C,OAAS/H,KAAKyT,SAAS1L,KAC7B,MAAM,IAAIjG,WACR,gEAGJ9B,KAAKyT,SAAWvO,EAAI4O,UAlFxB,yCAqFqBjM,GACjB,IAAMlB,EAASgJ,SAASqB,cAAc,UAChC7I,EAAUxB,EAAOyB,WAAW,MAClC,IAAKD,EAAS,MAAM,IAAIsH,MAAM,oCAE9B9I,EAAOU,MAAQQ,EAAMkM,aACrBpN,EAAOW,OAASO,EAAMmM,cACtB7L,EAAQ+I,UAAUrJ,EAAO,EAAG,GAE5B7H,KAAKiU,oBAAoBtN,KA9F7B,0CAiGsBA,GAClB,IAAMwB,EAAUxB,EAAOyB,WAAW,MAClC,IAAKD,EAAS,MAAM,IAAIsH,MAAM,oCAE9B,IAAMyE,EAAavN,EAAOU,MAAQrH,KAAKwT,YACjCW,EAAaxN,EAAOW,OAAStH,KAAKwT,YACxCxT,KAAKoU,YAAW,YAAa,IAAD,mBAAVpS,EAAU,KAAP0R,EAAO,KAClBW,EAASlM,EAAQmM,aACvBtS,EAAIkS,EACJR,EAAIS,EACJ,EACA,GAJME,KADkB,cAQLA,EARK,GAQnBtT,EARmB,KAQhBC,EARgB,KAQbC,EARa,KAU1B,OADoB,IATM,KASFO,EAASiC,SAAW,IAAIjC,EAAST,EAAGC,EAAGC,QAhHrE,8BAsHIjB,KAAKoU,YAAW,kBAAM5S,EAASiC,cAtHnC,iCAyHazB,EAAW0R,EAAWzP,GAG/B,IAFuBjE,KAAKyT,SAAST,IAAI,CAAChR,EAAG0R,IAG3C,MAAM5R,WAAW,YAAD,OAAaE,EAAb,YAAkB0R,EAAlB,oBAGlB1T,KAAKyT,SAASrB,IAAI,CAACpQ,EAAG0R,GAAIzP,KAhI9B,iCAmIajC,EAAW0R,GACpB,IAAMa,EAAavU,KAAKyT,SAASnB,IAAI,CAACtQ,EAAG0R,IAEzC,QAAmB5D,IAAfyE,EACF,MAAMzS,WAAW,YAAD,OAAaE,EAAb,YAAkB0R,EAAlB,oBAElB,OAAOa,IAzIX,0BA6II/B,GAEA,IADK,EACCgC,EAAU,IAAIC,MADf,eAEoBzU,KAAKyT,SAASR,WAFlC,IAEL,2BAAkD,CAAC,IAAD,yBAC1CyB,EAAgBlC,EAD0B,WAEhDgC,EAAQnB,KAAKqB,IAJV,8BAOL,OAAOF,IArJX,iCAyJIhC,GAIC,IAAD,iBACyBxS,KAAKyT,SAASR,WADvC,IACA,2BAAkD,CAAC,IAAD,yBAAxCG,EAAwC,KAC1CuB,EAASnC,EAAWY,EADsB,MAEhDpT,KAAKyT,SAASrB,IAAIgB,EAAKuB,IAHzB,iCA7JJ,8BAqKInC,GAIC,IAAD,iBACyBxS,KAAKyT,SAASR,WADvC,IACA,2BAAkD,CAAC,IAAD,yBAChDT,EADgD,YADlD,kCAzKJ,oCACsBoC,EAA0BjO,GAC5C,IAAMwB,EAAUxB,EAAOyB,WAAW,MAClC,IAAKD,EAAS,MAAM,IAAIsH,MAAM,oCAC9BmF,EAAYjC,SAAQ,WAAS1O,GAAW,IAAD,mBAAjBjC,EAAiB,KAAd0R,EAAc,KACjCzP,IAAUzC,EAASiC,UAKvB0E,EAAQe,UAAYjF,EAAMiC,QAC1BiC,EAAQ0M,SAAS7S,EAAG0R,EAAG,EAAG,IALxBvL,EAAQE,UAAUrG,EAAG0R,EAAG,EAAG,QANnC,8CAgBIkB,EACAjO,GACC,IACOU,EAAkBV,EAAlBU,MAAOC,EAAWX,EAAXW,OACTkM,EAAYoB,EAAYpB,YAE9B,OAAInM,IAAUC,GAIVkM,IAAcnM,MA1BtB,iDA2LI,OAAOzG,KAAKkU,KAAK9U,KAAKyT,SAAS1L,QA3LnC,iCA+LIgN,EACAC,EACA/Q,GACC,IAAD,EAC2BjE,KAAKiV,cAAcF,EAAOC,GAA7CE,EADR,EACQA,OAAQC,EADhB,EACgBA,OAEV1Q,EAAezE,KAAKoV,WAAWF,EAAQC,GAE/B,aAAVlR,GAAyC,aAAjBQ,KAId,aAAVR,GAAyC,aAAjBQ,KAKd,aAAVR,GAAyC,aAAjBQ,GAKd,aAAVR,GAAyC,aAAjBQ,IACrBjD,EAASkD,OAAOT,EAAOQ,IAC1BzE,KAAKqV,WAAWH,EAAQC,EAAQlR,IAXlCjE,KAAKqV,WAAWH,EAAQC,EAAQlR,MA5MtC,oCA6NI8Q,EACAC,GACC,IAAD,ECnOG,SACLD,EACAC,GAEA,IAAMM,EAAUP,EAAMQ,QAChBC,EAAUT,EAAMU,QAChBC,EAAQV,EAAuBW,wBAE/BC,EAAO,SAACzD,EAAehR,EAAaE,GAA7B,OACXT,KAAKO,IAAIE,EAAKT,KAAKS,IAAI8Q,EAAOhR,KAE1B0U,EAAWD,EAAKN,EAAUI,EAAKpE,KAAM,EAAGoE,EAAKrO,MAAQ,GACrDyO,EAAWF,EAAKJ,EAAUE,EAAK9P,IAAK,EAAG8P,EAAKpO,OAAS,GAI3D,MAAO,CAAEyO,UAFSF,EAAWH,EAAKrO,MAEH2O,UADbF,EAAWJ,EAAKpO,QDqNC2O,CAAyBlB,EAAOC,GAAzDe,EADR,EACQA,UAAWC,EADnB,EACmBA,UACbE,EAAUH,EAAY/V,KAAKwT,YAC3B2C,EAAUH,EAAYhW,KAAKwT,YAGjC,MAAO,CAAE0B,OAFMtU,KAAKwV,MAAMF,GAETf,OADFvU,KAAKwV,MAAMD,QApO9B,KEDaE,GAAb,8MACUC,WAAa,IAAI7B,MAD3B,qDAII,IAAM8B,EAAWvW,KAAK4F,MAMtB,YALiBkK,IAAbyG,GAA0BvW,KAAKwW,kBAAoB,GACrDxW,KAAKsW,WAAWjD,KAAKkD,GAGJ,iEATvB,iCAaapE,GACTnS,KAAKsW,WAAa,GAClB,oEAAiBnE,KAfrB,oCAmBI,OAAO,wEAnBX,oCAuBI,OAAOnS,KAAKsW,WAAW7V,SAvB3B,gCA2BI,IAAMgW,EAAQzW,KAAKsW,WAAWI,MAK9B,YAJc5G,IAAV2G,GACF,oEAAiBA,GAGZA,IAhCX,8BAoCIzW,KAAKsW,WAAa,GAClB,oEArCJ,GCFA,WAGE,WAAoBK,EAAiBC,GAAmB,yBAApCD,OAAmC,KAAlBC,UAAkB,KAFvDC,YAEuD,EACrD7W,KAAK6W,OAAS,CAACF,GAJnB,kDAQI,OAAO3W,KAAK6W,OAAO7W,KAAK6W,OAAOpW,OAAS,KAR5C,6BAYIT,KAAK6W,OAAOH,MACZ,IAAMI,EAAoB9W,KAAK6W,OAAO7W,KAAK6W,OAAOpW,OAAS,GAE3D,OAAIqW,IAGF9W,KAAK6W,OAAS,CAAC7W,KAAK2W,MACb3W,KAAK2W,QAnBlB,iCAuBaxE,GACTnS,KAAK6W,OAAOxD,KAAKlB,GAEbnS,KAAK4W,SAAW5W,KAAK4W,QAAU5W,KAAK6W,OAAOpW,SAC7CT,KAAK6W,OAAS7W,KAAK6W,OAAO5R,OAAOjF,KAAK4W,QAAU,MA3BtD,oCAgCI,OAAOhW,KAAKS,IAAIrB,KAAK6W,OAAOpW,OAAS,EAAG,KAhC5C,wCAoCI,OAAOT,KAAK6W,OAAOpW,SApCvB,8BAwCIT,KAAK6W,OAAS,OAxClB,MCKaE,GAAb,oDA0BE,WAAYvD,GAAoB,IAAD,8BAC7B,cAAMA,IAFRwD,gBAC+B,IA+GvBC,WAAa,SAACjV,EAAW0R,GAAZ,OAA0B,EAAKwD,cAAclE,IAAI,CAAChR,EAAG0R,KA5GxE,EAAKsD,WAAa,IAAIX,GAEpB,EAAKa,cAAcpD,SALQ,EA1BjC,uDAmCItB,GAKA,oEAAiBA,GACjBxS,KAAKgX,WAAWG,WAAWnX,KAAKkX,cAAcpD,WAzClD,iCA4Ca9R,EAAW0R,EAAWzP,GAC/B,oEAAiBjC,EAAG0R,EAAGzP,GACvBjE,KAAKgX,WAAWG,WAAWnX,KAAKkX,cAAcpD,WA9ClD,6BAkDI,IAAM9F,EAAOhO,KAAKgX,WAAWhJ,OAC7BhO,KAAKoX,YAAYpJ,KAnDrB,6BAuDI,IAAMD,EAAO/N,KAAKgX,WAAWK,eAChBvH,IAAT/B,GACF/N,KAAKoX,YAAYrJ,KAzDvB,oCA6DgB/L,EAAW0R,EAAW4D,GAClC,IAAMC,EAAavX,KAAKoV,WAAWpT,EAAG0R,GAEhC8D,EAAU,IAAI1F,GACpB9R,KAAKkX,cACFpD,QACAnB,SAAQ,SAAC1O,EAAD,GAAoB,IAAD,mBAAVjC,EAAU,KAAP0R,EAAO,KAC1B8D,EAAQpF,IAAI,CAACpQ,EAAG0R,IAAI,MAGA1T,KAAKyX,UAC3BzV,EACA0R,EACA4D,EACAC,EACAC,IAIAxX,KAAKgX,WAAWG,WAAWnX,KAAKkX,cAAcpD,WAhFpD,gCA4FI9R,EACA0R,EACA4D,EACAC,EACAC,GACU,IAAD,OAET,IADuBxX,KAAKiX,WAAWjV,EAAG0R,GACvB,OAAO,EAG1B,IAD0D,IAAxB8D,EAAQlF,IAAI,CAACtQ,EAAG0R,IACnB,OAAO,EAEtC,IAAMgE,EAAY1X,KAAKoV,WAAWpT,EAAG0R,GAKrC,IAJgCqD,EAAoBY,eAClDD,EACAH,GAE4B,OAAO,EAErC,IAAMK,EAAyBb,EAAoBY,eACjDD,EACAJ,GAIF,OADAE,EAAQpF,IAAI,CAACpQ,EAAG0R,IAAI,IAChBkE,IAIJ,oEAAiB5V,EAAG0R,EAAG4D,GAET,CACZ,CAACtV,EAAG0R,EAAI,GACR,CAAC1R,EAAG0R,EAAI,GACR,CAAC1R,EAAI,EAAG0R,GACR,CAAC1R,EAAI,EAAG0R,IAGJf,SAAQ,mCAAE3Q,EAAF,KAAK0R,EAAL,YACZ,EAAK+D,UAAUzV,EAAG0R,EAAG4D,EAAWC,EAAYC,OAGvC,OAtIX,GAAyCjE,IAA5BwD,GACJY,eAAiB,SACtBE,EACAC,GAEA,MAAe,aAAXD,GAAoC,aAAXC,IAId,aAAXD,GAAoC,aAAXC,MAId,aAAXD,GAAoC,aAAXC,MAId,aAAXD,GAAoC,aAAXC,IACvBtW,EAASkD,OAAOmT,EAAQC,M,wBCpBrBC,GAAQ,SAAC,GAI8C,IAHlE5J,EAGiE,EAHjEA,QACA6J,EAEiE,EAFjEA,SACAC,EACiE,EADjEA,QAEA,OACE,eAAC3J,EAAA,EAAD,CAAOI,OAAK,EAACwJ,KAAK,aAAazJ,eAAgBN,EAA/C,UACE,eAAChJ,EAAA,EAAD,CAAKE,UAAU,MAAMgE,KAAM,aAAc/D,QAAQ,UAAUI,IAAI,QAA/D,UACE,cAACyS,GAAA,EAAD,CACEC,UAAU,SACVC,MAAM,IACNC,OAAQ,CAAE1S,IAAK,IAAKyG,OAAQ,KAH9B,SAKG4L,IAEH,cAAC9S,EAAA,EAAD,CAAKE,UAAU,MAAMC,QAAQ,MAA7B,SACE,cAACO,EAAA,EAAD,CAAQE,KAAM,cAACwS,GAAA,EAAD,IAAWtS,QAAS,kBAAMkI,YAG5C,cAAChJ,EAAA,EAAD,CAAKkE,MAAI,EAAC3D,IAAI,QAAd,SACE,cAACP,EAAA,EAAD,CAAKiH,IAAI,QAAT,SAAkB4L,UCZbQ,GAAe,SAAC,GAOH,IANxBC,EAMuB,EANvBA,SACAC,EAKuB,EALvBA,SACAvK,EAIuB,EAJvBA,QAIuB,IAHvBwK,eAGuB,MAHb,gBAGa,MAFvBC,wBAEuB,MAFJ,SAEI,MADvBC,wBACuB,MADJ,SACI,EACvB,OACE,eAAC,GAAD,CAAO1K,QAASA,EAAS8J,QAAS,WAAlC,UACE,cAACnJ,EAAA,EAAD,CAAMsJ,UAAU,SAAhB,SAA0BO,IAC1B,eAAC,IAAD,CACE7M,QAAS,CAAEyF,MAAO,EAAGxJ,KAAM,CAAC,OAAQ,SACpCqE,IAAI,QACJ1G,IAAK,CAAEE,IAAK,SAAUyG,OAAQ,SAHhC,UAKE,cAACxG,EAAA,EAAD,CAAQiT,MAAOF,EAAkB3S,QAASyS,IAC1C,cAAC7S,EAAA,EAAD,CACEC,SAAO,EACPgT,MAAOD,EACP5S,QAASwS,EACTL,UAAU,e,oBCjBdW,GAAe,CACnB,MAAO,EACP,MAAO,EACP,QAAS,GACT,QAAS,GACT,QAAS,GACT,QAAS,GACT,QAAS,GACT,QAAS,GACT,QAAS,GACT,QAAS,IAGLC,GAAe,CACnBC,EAAG,MACHC,EAAG,MACHC,GAAI,QACJC,GAAI,QACJC,GAAI,QACJC,GAAI,QACJC,GAAI,QACJC,GAAI,QACJC,GAAI,QACJC,GAAI,SAGAC,GAAU,CACd,MACA,MACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,SAKWC,GAAkB,SAAC,GAOoB,IANlDpG,EAMiD,EANjDA,UACAqG,EAKiD,EALjDA,kBACG3P,EAI8C,iDACjD,OACE,cAAC4P,GAAA,EAAD,CAAWhB,MAAM,0BAAjB,SACE,cAACiB,GAAA,EAAD,aACE9N,KAAK,oBACL+N,YAAY,MACZ7H,MAAO6G,GAAaxF,GACpBmG,QAASA,GACTM,SAAU,gBAAGC,EAAH,EAAGA,OAAH,OACRL,EAAkBd,GAAamB,MAE7BhQ,OCxECiQ,GAAa,SAAC,GAMpB,IALLC,EAKI,EALJA,eACAC,EAII,EAJJA,YAKMjV,EAAML,iBAAyB,MACrC,OACE,qCACE,cAACc,EAAA,EAAD,CACEkC,KAAK,QACL+Q,MAAM,eACN7S,QAAS,WACP,IAAMqU,EAAQlV,EAAIwB,QACb0T,GACLA,EAAMzJ,WAIV,uBACEzL,IAAKA,EACLe,MAAO,CAAEoD,QAAS,QAClB0Q,SAAQ,yCAAE,WAAOnT,GAAP,kBAAA5D,EAAA,6DACFqX,EAAe,IAAInL,SACvB,SAACC,EAASC,GACR,GAAKxI,EAAMkO,OAAO/E,OAAUnJ,EAAMkO,OAAO/E,MAAM,GAA/C,CACA,IAAMuK,EAAWC,IAAIC,gBAAgB5T,EAAMkO,OAAO/E,MAAO,IACnDpI,EAAQ,IAAI8S,MAClB9S,EAAMC,IAAM0S,EACZ3S,EAAM+S,OAAS,kBAAMvL,EAAQxH,QAGtB,OAAXwS,QAAW,IAAXA,KAAcE,GAVN,SAWYA,EAXZ,OAWF1S,EAXE,OAYRuS,EAAevS,GAZP,2CAAF,sDAcRJ,KAAK,OACLoT,OAAO,gBChCFC,GAAe,SAAC,GAWtB,IAVLC,EAUI,EAVJA,iBACArC,EASI,EATJA,SACAsC,EAQI,EARJA,YAQI,EACkClR,qBADlC,mBACGmR,EADH,KACgBb,EADhB,OAE0BtQ,oBAAS,GAFnC,mBAEGoR,EAFH,KAEYC,EAFZ,OAG8BrR,mBAA0BiR,GAHxD,mBAGGvH,EAHH,KAGc4H,EAHd,KASJ,OAJA7W,qBAAU,WACR6W,EAAaL,KACZ,CAACA,IAGF,eAAC,GAAD,CAAO5M,QAASuK,EAAUT,QAAQ,cAAlC,UACE,cAAC,GAAD,CAAiB4B,kBAAmBuB,EAAc5H,UAAWA,IAC7D,eAACrO,EAAA,EAAD,CACEE,UAAU,MACV+G,IAAI,QACJ/C,KAAK,aACL/D,QAAQ,UACRI,IAAK,CAAE4L,KAAM,OALf,UAOE,cAACxC,EAAA,EAAD,CAAMsJ,UAAU,SAAhB,qCACA,cAAC,GAAD,CACEgC,eAAgBA,EAChBC,YAAW,yCAAE,WAAOgB,GAAP,UAAAnY,EAAA,6DACXiY,GAAW,GADA,SAELE,EAFK,OAGXF,GAAW,GAHA,2CAAF,2DAQf,eAAC,IAAD,CACErP,QAAS,CAAEyF,MAAO,EAAGxJ,KAAM,CAAC,OAAQ,SACpCqE,IAAI,QACJ1G,IAAK,CAAEE,IAAK,SAAUyG,OAAQ,SAHhC,UAKE,cAACxG,EAAA,EAAD,CAAQiT,MAAM,SAAS7S,QAASyS,IAEhC,cAAC7S,EAAA,EAAD,CACEC,SAAO,EACPwV,SAAUJ,EACVpC,MAAOoC,EAAU,gBAAkB,aACnCjV,QAAS,kBAAM+U,EAAYxH,EAAWyH,aCzD1CtB,GAAU,CAAC,eAAgB,eAAgB,YAE3CZ,GAAe,CACnB,eAAgB,MAChB,eAAgB,MAChBwC,SAAU,YAGCC,GAAgB,SAAC,GAMT,IALnBlX,EAKkB,EALlBA,QACAmX,EAIkB,EAJlBA,gBAKMC,EAAmB5X,EACzB,OACE,cAACiW,GAAA,EAAD,CACE9N,KAAK,iBACL+N,YAAa0B,EAAiB/X,IAC9BwO,MAAOrO,EAAsBQ,GAC7BqV,QAASA,GACTM,SAAU,gBAAGC,EAAH,EAAGA,OAAH,OACRuB,EAAgB1C,GAAamB,QChBxByB,GAAe,SAAC,GActB,IAbLjD,EAaI,EAbJA,SACAkD,EAYI,EAZJA,SAYI,IAXJtX,eAWI,MAXM,MAWN,MAVJH,oBAUI,MAVW,GAUX,EATJ0X,EASI,EATJA,gBACAC,EAQI,EARJA,WAQI,EACoChS,mBAA4BxF,GADhE,mBACGyX,EADH,KACiBC,EADjB,KAGEC,EADgBvY,EAAuBqY,GACP7W,IAAI1D,EAASgB,eAH/C,ECvBsB,SAC1B0Z,EACAC,EACAC,GAIA,IAAMC,EAAUtX,mBACVuX,EAAevX,kBAAO,GAEtBwX,EAAgB,WACpBF,EAAQzV,SAAW0G,aAAa+O,EAAQzV,SACxCyV,EAAQzV,aAAUkJ,GAiBpB,MAAO,CAAE0M,YAdW,SAAC1V,GACnBuV,EAAQzV,QAAUyG,YAAW,WAC3BiP,EAAa1V,SAAU,EACvBsV,EAAoBpV,GACpByV,MACCJ,IASiBM,UANJ,SAAC3V,QACOgJ,IAApBuM,EAAQzV,UACZ2V,IACiB,OAAjBH,QAAiB,IAAjBA,KAAoBtV,KAGWwV,gBDIEI,EACjC,SAAC5V,GACC,GAAK+U,EAAL,CACA,IAAMpW,EAAQkX,GAAe7V,GAC7B,QAAcgJ,IAAVrK,EAAJ,CAEA,IAAMxB,EAAQgY,EAAgBxW,GAM9B,KAJmBtB,EAAayY,MAAK,SAAC9O,GAAD,OACnCtM,EAASkD,OAAOoJ,EAAQ7J,MAGZ,CACZ,IAAM4Y,EAAsB,YAAI1Y,GAAcK,QAC5C,SAACsJ,GAAD,OAAatM,EAASkD,OAAOT,EAAO6J,MAEtC+N,EAAgBgB,OACX,CACL,IAAMA,EAAmB,YAAO1Y,GAChC0Y,EAAoBxJ,KAAKpP,GACzB4X,EAAgBgB,QAGpB,KACA,SAAC/V,GACC,QAAcgJ,IAAVhJ,EAAJ,CACAA,EAAMgW,iBACN,IAAMC,EAAaJ,GAAe7V,GAClC,QAAmBgJ,IAAfiN,EAAJ,CAEA,IAAM9Y,EAAQgY,EAAgBc,GAC9BnB,EAAS3X,GACTyU,SAhCI8D,EAVJ,EAUIA,YAAaC,EAVjB,EAUiBA,UAmCrB,OACE,eAAC,GAAD,CAAOtO,QAASuK,EAAUT,QAAS,UAAnC,UACE,cAAC9S,EAAA,EAAD,CAAKkE,MAAI,EAAC3D,IAAK,CAAEE,IAAK,QAASyG,OAAQ,SAAWD,IAAI,QAAtD,SACE,cAACjH,EAAA,EAAD,CACEE,UAAU,MACVE,MAAI,EACJD,QAAQ,UACR8S,UAAU,SACV4E,aAAcR,EACdjV,WAAYkV,EANd,SAQGvM,OAAOgD,OAAO+I,GAAiB/W,KAAI,SAACjB,EAAOwB,GAC1C,IAAMwX,IAAa9Y,EAAayY,MAAK,SAAC9O,GAAD,OACnCtM,EAASkD,OAAOoJ,EAAQ7J,MAE1B,OACE,cAACkB,EAAA,EAAD,CAEEmC,OAAO,SACPD,MAAM,SACN3B,IAAK,CAAE2G,OAAQ,UAJjB,SAME,cAACxG,EAAA,EAAD,CACEC,SAAO,EACPuD,KAAK,WACLtB,KAAK,QAELmV,aAAYzX,EACZxB,MAAOA,EAAMiC,QACbH,KAAMkX,EAAW,cAACrQ,EAAA,EAAD,SAAUkD,EAC3B3J,MAAO,CACLC,aAAc,IACd+W,OAAQ,SANL1X,IATFA,UAuBf,cAACN,EAAA,EAAD,CAAKO,IAAK,CAAEE,IAAK,QAASyG,OAAQ,SAAWD,IAAI,QAAjD,SACE,cAAC,GAAD,CAAe9H,QAASA,EAASmX,gBAjFf,SAACnX,GACvB0X,EAAgB1X,GACN,OAAVwX,QAAU,IAAVA,KAAaxX,YAoFjB,SAASqY,GAAe7V,GACtB,IAAMsW,EAAoBtW,EAAMkO,OAA6BqI,QAAQ5X,MACrE,GAAK2X,EAEL,OAAOva,SAASua,EAAkB,I,wBE/G9BE,GAAwC,CAC5C,eACA,QACA,SAEWC,GAA0B,SAAC,GAQjC,IAAD,EAPJ7E,EAOI,EAPJA,SACA8E,EAMI,EANJA,OACYC,EAKR,EALJhX,WAKI,EACgCqD,mBAAqB2T,GADrD,mBACGhX,EADH,KACeiX,EADf,OAE+C5T,oBAAS,GAFxD,mBAEG6T,EAFH,KAEwBC,EAFxB,KAYJ,OACE,qCACE,eAAC,GAAD,CAAOzP,QAASuK,EAAUT,QAAS,4BAAnC,UACE,cAAC6B,GAAA,EAAD,CAAWhB,MAAM,OAAjB,SACE,cAACiB,GAAA,EAAD,CACE5H,MAAO1L,EAAWgB,KAClBkS,QAAS2D,GACTrD,SAfqB,SAAC,GAIzB,IAHLC,EAGI,EAHJA,OAIAwD,EAAc,2BAAKjX,GAAN,IAAkBgB,KAAMyS,UAcZ,UAApBzT,EAAWgB,MACV,eAACtC,EAAA,EAAD,CAAKiH,IAAI,QAAT,UACE,cAAC0N,GAAA,EAAD,CAAWhB,MAAM,kBAAkB7M,KAAK,SAAxC,SACE,cAAC8N,GAAA,EAAD,CACE5H,MAAOsL,EAAoB1V,KAC3B4R,QAAS,CAAC,QAAS,WACnBM,SAAU,gBAAWlS,EAAX,EAAGmS,OAAH,OACRwD,EAAc,2BAAKjX,GAAN,IAAkBsB,eAKrC,eAAC5C,EAAA,EAAD,CACEE,UAAU,MACV+G,IAAI,QACJ/C,KAAK,aACL/D,QAAQ,UACRI,IAAK,CAAE4L,KAAM,OALf,UAOE,cAACxC,EAAA,EAAD,CAAMsJ,UAAU,SAAhB,8BACA,cAAC,GAAD,CACEgC,eAAgB,SAACvS,GAAD,OACd6V,EAAc,2BAAKjX,GAAN,IAAkBoB,iBAKrC,cAAC1C,EAAA,EAAD,CAAKkC,MAAM,QAAQC,OAAO,QAAQ5B,IAAI,QAAtC,SACE,cAAC,KAAD,CACES,MAAO,CAAEwB,gBAAiBlB,EAAWxC,MAAMiC,SAC3C4B,KAAK,UAAArB,EAAWoB,aAAX,eAAkBC,MC3ExB,yID4EC+V,IAAKpX,EAAWsB,YAMH,iBAApBtB,EAAWgB,MACV,eAACtC,EAAA,EAAD,CACEE,UAAU,MACV+G,IAAI,QACJ/C,KAAK,aACL/D,QAAQ,UACRI,IAAK,CAAE4L,KAAM,OALf,UAOE,cAACxC,EAAA,EAAD,CAAMsJ,UAAU,SAAhB,8BACA,cAACvS,EAAA,EAAD,CACEkC,KAAK,QACLjC,SAAO,EACP7B,MAAQwC,EAAWxC,MAAmBiC,QACtC4S,MAAO,eACP7S,QAAS,kBAAM2X,GAAoB,SAKzC,eAAC,IAAD,CACE9R,QAAS,CAAEyF,MAAO,EAAGxJ,KAAM,CAAC,OAAQ,SACpCqE,IAAI,QACJ1G,IAAK,CAAEE,IAAK,SAAUyG,OAAQ,SAHhC,UAKE,cAACxG,EAAA,EAAD,CAAQiT,MAAM,SAAS7S,QAASyS,IAEhC,cAAC7S,EAAA,EAAD,CACEC,SAAO,EACPgT,MAAM,OACN7S,QAAS,WACPuX,EAAO/W,YAKdkX,GACC,cAAC,GAAD,CACEjF,SAAU,kBAAMkF,GAAoB,IACpChC,SAAU,SAAC3X,GAAD,OAAWyZ,EAAc,2BAAKjX,GAAN,IAAkBxC,kBE5GjD6Z,GAAgB,SAAC,GAcvB,IAbLpF,EAaI,EAbJA,SACA8E,EAYI,EAZJA,OACAO,EAWI,EAXJA,YACAC,EAUI,EAVJA,WACAC,EASI,EATJA,aACAxX,EAQI,EARJA,WAQI,EAIAqD,oBAAS,GAJT,mBAEFoU,EAFE,KAGFC,EAHE,OAMwCrU,mBAAqBrD,GAN7D,mBAMG2X,EANH,KAMmBC,EANnB,OAOuCvU,mBAASmU,GAPhD,mBAOGK,EAPH,KAOsBC,EAPtB,KASJ,OACE,qCACE,cAAC,GAAD,CAAOpQ,QAASuK,EAAUT,QAAS,WAAnC,SACE,eAAC9S,EAAA,EAAD,CAAKiH,IAAI,QAAT,UACE,eAACjH,EAAA,EAAD,CACEE,UAAU,MACV+G,IAAI,QACJ/C,KAAK,aACL/D,QAAQ,UACRI,IAAK,CAAE4L,KAAM,OALf,UAOE,cAACxC,EAAA,EAAD,CAAMsJ,UAAU,SAAhB,uBACA,cAACoG,GAAA,EAAD,CACEC,QAAM,EACNxE,SAAU,SAACnT,GAAD,OAAWiX,EAAYjX,EAAMkO,OAAO0J,UAC9CA,QAASV,OAEN,IACP,eAAC7Y,EAAA,EAAD,CACEE,UAAU,MACV+G,IAAI,QACJ/C,KAAK,aACL/D,QAAQ,UACRI,IAAK,CAAE4L,KAAM,OALf,UAOE,cAACxC,EAAA,EAAD,CAAMsJ,UAAU,SAAhB,2BACA,cAACoG,GAAA,EAAD,CACEC,QAAM,EACNxE,SAAU,SAACnT,GAAD,OAAWyX,EAAczX,EAAMkO,OAAO0J,UAChDA,QAASJ,OAGb,eAACnZ,EAAA,EAAD,CACEE,UAAU,MACV+G,IAAI,QACJ/C,KAAK,aACL/D,QAAQ,UACRI,IAAK,CAAE4L,KAAM,OALf,UAOE,cAACxC,EAAA,EAAD,CAAMsJ,UAAU,SAAhB,8BAEA,cAACvS,EAAA,EAAD,CACEkC,KAAK,QACL+Q,MAAM,WACN7S,QAAS,kBAAMkY,GAAgC,SAGnD,eAAC,IAAD,CACErS,QAAS,CAAEyF,MAAO,EAAGxJ,KAAM,CAAC,OAAQ,SACpCqE,IAAI,QACJ1G,IAAK,CAAEE,IAAK,SAAUyG,OAAQ,SAHhC,UAKE,cAACxG,EAAA,EAAD,CAAQiT,MAAM,SAAS7S,QAASyS,IAEhC,cAAC7S,EAAA,EAAD,CACEC,SAAO,EACPgT,MAAM,OACN7S,QAAS,WACPuX,EAAO,CACLY,iBACAJ,aACAC,aAAcK,eAOzBJ,GACC,cAAC,GAAD,CACExF,SAAU,kBAAMyF,GAAgC,IAChDX,OAAQ,SAAC/W,GACP4X,EAAkB5X,GAClB0X,GAAgC,IAElC1X,WAAYA,QCpFhBkY,GAAcC,oBAAUC,IAPC,CAC7B9Y,KAAM,CACJgC,KAAM,CAAE+W,OAAQ,SAElBC,OAAQ,CAAEC,SAAU,CAAEC,MAAO,UAgSzBC,GAAiB,SACrBC,EACAC,GACI,IAAD,EACuBtV,mBAAkBqV,GADzC,mBACIE,EADJ,KACWC,EADX,KAqBH,MAAO,CAACD,EAlBgBE,uBACtB,SAAC9T,GACC,OAAQA,GACN,IAAK,OACH6T,EAAS,QACT,MAEF,IAAK,QACHA,EAAS,SAKbF,EAAQ3T,KAEV,CAAC2T,MAMUI,GAnTH,WAAO,IAAD,EAC8B1V,mBAA0B,IADxD,mBACTtD,EADS,KACQiZ,EADR,OAEU3V,mBACxBtI,EAASgB,cALQ,YAEH,mBAETyB,EAFS,KAEF2X,EAFE,OAM8B9R,wBAE5CgG,GARc,mBAMT4P,EANS,KAMeC,EANf,OAUQ7V,mBAAgB,SAVxB,mBAUT2B,EAVS,KAUH2T,EAVG,OAYoBtV,mBAAqB,CACvDrC,KAAM,eACNI,WAAOiI,EACP7L,MAAO,IAAIzC,EAAS,EAAG,EAAG,GAC1BuG,KAAM,UAhBQ,mBAYTtB,EAZS,KAYGiX,EAZH,OAmBiBwB,GAAe,QAASE,GAnBzC,mBAmBTC,EAnBS,KAmBFO,EAnBE,OAoBc9V,mBAAmB,SApBjC,mBAoBT8B,EApBS,KAoBAiU,EApBA,OAqBoB/V,mBAElC,UAvBc,mBAqBT5F,EArBS,KAqBG4b,EArBH,OAwBiBhW,mBAAmB,OAxBpC,mBAwBTH,EAxBS,KAwBCoW,EAxBD,OAyBmCjW,oBAAS,GAzB5C,mBAyBT6T,EAzBS,KAyBYC,EAzBZ,OA6BZ9T,oBAAS,GA7BG,mBA2BdkW,EA3Bc,KA4BdC,GA5Bc,QA8BcnW,mBAjCT,OAGL,qBA8BTxF,GA9BS,MA8BAwX,GA9BA,SA+BkBhS,qBA/BlB,qBA+BToH,GA/BS,MA+BEgP,GA/BF,SAgCkCpW,oBAAS,GAhC3C,qBAgCTqW,GAhCS,MAgCYC,GAhCZ,SAiCoCtW,oBAAS,GAjC7C,qBAiCTuW,GAjCS,MAiCYhP,GAjCZ,SAkCgBvH,oBAAS,GAlCzB,qBAkCTwW,GAlCS,MAkCCvC,GAlCD,SAmCsBjU,oBAAS,GAnC/B,qBAmCTmU,GAnCS,MAmCKM,GAnCL,SAoCYzU,qBApCZ,qBAoCTnD,GApCS,MAoCDoD,GApCC,SAqCwBD,mBAAqB,IArC7C,qBAqCT3F,GArCS,MAqCK0X,GArCL,SAsCwB/R,mBAAqB,IAtC7C,qBAsCT1F,GAtCS,MAsCKC,GAtCL,MAwCVuJ,GAAQ5G,mBAAQ,WACpB,OAAO,IAAI+P,GAAoBvQ,KAC9B,CAACA,IAEJjC,qBAAU,WACJ2M,GACFtD,GAAM2S,mBAAmBrP,IAEzBtD,GAAMyE,QAGRzE,GAAMgG,iBACL,CAAC1C,GAAW1K,EAAiBG,GAAQiH,KAExC,IAqFM5J,GAA2B,SAACC,GAChC2X,EAAS3X,GACTmb,EAAQC,IAGJmB,KAAwBd,EAE9B,OACE,eAACe,EAAA,EAAD,CACEC,MAAO/B,GACPxY,MAAO,CAAEmB,OAAQ,QACjBqZ,UAAWL,GAAW,OAAS,QAHjC,UAKE,eAAC,IAAD,CACEjX,MAAI,EACJ2C,MAAO,CACL,CAAEC,KAAM,SAAUC,MAAO,CAAC,EAAG,GAAIC,IAAK,CAAC,EAAG,IAC1C,CAAEF,KAAM,SAAUC,MAAO,CAAC,EAAG,GAAIC,IAAK,CAAC,EAAG,IAC1C,CAAEF,KAAM,OAAQC,MAAO,CAAC,EAAG,GAAIC,IAAK,CAAC,EAAG,IACxC,CAAEF,KAAM,SAAUC,MAAO,CAAC,EAAG,GAAIC,IAAK,CAAC,EAAG,KAE5CL,QAAS,CAAC,QACVC,KAAM,CAAC,OAAQ,OAAQ,OAAQ,QATjC,UAWE,cAAC6U,EAAA,EAAD,CAAQtU,SAAS,SAAShH,QAAQ,SAAlC,wBAGC2Y,IAAgB+B,GACf,cAAC,GAAD,CACE7R,QAAS,kBAAM8R,IAA8B,IAC7CrU,QAASA,IAGb,cAAC,EAAD,CACE/B,WAAY,CAAEyC,SAAU,SAAUuU,iBAAkB,SACpDlX,SAAUA,EACVrD,gBAjFgB,SAACK,GACvBoD,GAAUpD,GACViH,GAAM7D,UAAUpD,IAgFViD,cA1Hc,SACpBjD,EACAG,GAEA,IAAMiO,EAAQjO,EAAMga,eAAe,GAC7B9L,EAASlO,EAAMkO,OACrB,QAAclF,IAAViF,EACF,MAAM,IAAItF,MAAM,iCAElB,IAAMsR,EAASnT,GAAMqH,cAAcF,EAAOC,GAC1C,OAAQvJ,GACN,IAAK,UACH2T,EAAQC,GACR,IAAM2B,EAAgBpT,GAAMwH,WAAW2L,EAAO7L,OAAQ6L,EAAO5L,QAC7D,GAAI6L,IAAkBxf,EAASiC,SAAU,MACzCmY,EAASoF,GACT,MAEF,IAAK,QACHpT,GAAM7D,UAAUpD,GAChBiH,GAAMqT,WAAWlM,EAAOC,EAAQ/Q,GAChC2J,GAAMgG,eACN,MAEF,IAAK,SACHhG,GAAM7D,UAAUpD,GAChBiH,GAAMqT,WAAWlM,EAAOC,EAAQxT,EAASiC,UACzCmK,GAAMgG,eACN,MAEF,IAAK,OACHhG,GAAM7D,UAAUpD,GAChBiH,GAAMsT,cAAcH,EAAO7L,OAAQ6L,EAAO5L,OAAQlR,GAClD2J,GAAMgG,iBA0FJpN,gBAAiBA,EACjBC,WAAYA,IAGd,eAAC0a,EAAA,EAAD,CAAM7U,SAAS,OAAO5G,IAAI,QAAQ0b,UAAU,SAA5C,UACE,cAAC,EAAD,CACEnd,MAAOA,EACPwH,KAAMA,EACN9B,SAAUA,EACVuB,kBAAmB4U,EACnB7U,aAAc2U,EACdtU,kBA9EgB,WACxB,OAAQ3B,GACN,IAAK,MACHoW,EAAa,SACb,MACF,IAAK,QACHA,EAAa,QACb,MACF,IAAK,OACHA,EAAa,SAsET1U,qBAhFmB,kBAAMuS,GAAqBD,IAiF9CvS,YAtFU,WAClBwC,GAAMG,OACNH,GAAMgG,gBAqFEzI,YA5FU,WAClByC,GAAMI,OACNJ,GAAMgG,gBA2FErI,aApEW,kBACnBoU,EAAY,CACVlH,SAAU,WACRkH,OAAY7P,GAEZlC,GAAMyE,QACNzE,GAAMgG,gBAER+E,QAAS,6CACTE,iBAAkB,QAClBH,SAAU,WACRiH,OAAY7P,IAEd3B,QAAS,kBAAMwR,OAAY7P,OAwDrB5L,WAAYA,EACZsH,gBAAiB,SAACI,GAChBiU,EAAWjU,GAEG,YAAZA,GACY,UAAZA,GACAqS,IAEAgC,IAA8B,MAKpC,cAAC,EAAD,CACE5b,gBAAiBA,GACjBD,aAAcA,GACdF,WAAYA,EACZD,MAAOA,EACPK,QAASA,GACTH,aAAcA,GACdH,yBAA0BA,QAG7B2C,IACC,cAAC,GAAD,CACE2F,SAAS,SACT3F,OAAQA,GACRyK,mBAAoB,kBAAMgP,IAAmB,IAC7C/O,qBAAsBA,QAK3BsM,GACC,cAAC,GAAD,CACExZ,aAAcA,GACd0X,gBAAiBA,GACjBnD,SAAU,kBAAMkF,GAAoB,IACpChC,SAAU5X,GACVM,QAASA,GACTwX,WAAYA,KAIf0E,IACC,cAAC,GAAD,CACErS,QAASuR,EAAwBvR,QACjCsK,SAAUiH,EAAwBjH,SAClCC,SAAUgH,EAAwBhH,SAClCE,iBAAkB8G,EAAwB9G,iBAC1CC,iBAAkB6G,EAAwB7G,iBAC1CF,QAAS+G,EAAwB/G,UAIpCwH,IACC,cAAC,GAAD,CACEpF,iBAAkBvU,EAClBkS,SAAU,kBAAM0H,IAAmB,IACnCpF,YAAa,SAACxH,EAAW6N,GACvBnB,GAAamB,GACb5B,EAAmBjM,GACnB4M,IAAmB,MAKxBC,IACC,cAAC,GAAD,CACE5Z,WAAYA,EACZuX,WAAYsC,GACZrC,aAAcA,GACdvF,SAAU,kBAAMrH,IAAqB,IACrC0M,YAAaA,GACbP,OAAQ,SAAC8D,GAAkB,IACjBlD,EAA6CkD,EAA7ClD,eAAgBJ,EAA6BsD,EAA7BtD,WAAYC,EAAiBqD,EAAjBrD,aACpCM,GAAcN,GACdF,GAAYC,GACZN,EAAcU,GACd/M,IAAqB,U,OC1SjCkQ,OAAOC,cAAgB,SAAU1a,GAG/B,OAFAA,EAAMgW,iBACNhW,EAAM2a,mBACC,GAGTC,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,GAAD,MAEFjS,SAASkS,eAAe,U","file":"static/js/main.298bb612.chunk.js","sourcesContent":["import { RGBColor } from \"./RGBColor\";\n\nexport class HSLColor {\n  /**\n   * @param hslString A string following the possible forms\n   * hsl(180 100% 50%)\n   * hsl(180deg,100%,50%)\n   * hsl(180deg 100% 50%)\n   * hsl(3.14rad,100%,50%)\n   * hsl(3.14rad 100% 50%)\n   * hsl(0.5turn,100%,50%)\n   * hsl(0.5turn 100% 50%)\n   */\n  static fromHSLString(hslString: string) {\n    let sep = hslString.indexOf(\",\") > -1 ? \",\" : \" \";\n    const hsl = hslString.substr(4).split(\")\")[0].split(sep);\n\n    let hString = hsl[0];\n    let s = parseFloat(hsl[1].substr(0, hsl[1].length - 1)) / 100;\n    let l = parseFloat(hsl[2].substr(0, hsl[2].length - 1)) / 100;\n\n    let h = 0;\n\n    if (hString.indexOf(\"deg\") > -1)\n      hString = hString.substr(0, hString.length - 3);\n    else if (hString.indexOf(\"rad\") > -1)\n      h = Math.round(\n        parseFloat(hString.substr(0, hString.length - 3)) * (180 / Math.PI)\n      );\n    else if (hString.indexOf(\"turn\") > -1)\n      h = Math.round(parseFloat(hString.substr(0, hString.length - 4)) * 360);\n    // Keep hue fraction of 360 if ending up over\n    if (h >= 360) h %= 360;\n\n    return new HSLColor(h, s, l);\n  }\n\n  static fromRGB(r: number, g: number, b: number) {\n    // Make r, g, and b fractions of 1\n    r /= 255;\n    g /= 255;\n    b /= 255;\n\n    // Find greatest and smallest channel values\n    let cMin = Math.min(r, g, b);\n    let cMax = Math.max(r, g, b);\n    let delta = cMax - cMin;\n    let h = 0;\n    let s = 0;\n    let l = 0;\n\n    // Calculate hue\n    // No difference\n    if (delta === 0) h = 0;\n    // Red is max\n    else if (cMax === r) h = ((g - b) / delta) % 6;\n    // Green is max\n    else if (cMax === g) h = (b - r) / delta + 2;\n    // Blue is max\n    else h = (r - g) / delta + 4;\n\n    h = Math.round(h * 60);\n\n    // Make negative hues positive behind 360°\n    if (h < 0) h += 360;\n\n    // Calculate lightness\n    l = (cMax + cMin) / 2;\n\n    // Calculate saturation\n    s = delta === 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));\n\n    return new HSLColor(h, s, l);\n  }\n\n  constructor(hue: number, saturation: number, lightness: number) {\n    this.hsl = [hue, saturation, lightness];\n  }\n\n  hsl: [number, number, number];\n\n  get h() {\n    return this.hsl[0];\n  }\n  get s() {\n    return this.hsl[1];\n  }\n  get l() {\n    return this.hsl[2];\n  }\n\n  set h(h: number) {\n    this.hsl[0] = h;\n  }\n  set s(s: number) {\n    this.hsl[1] = s;\n  }\n  set l(l: number) {\n    this.hsl[2] = l;\n  }\n\n  toHSLString() {\n    const [h, s, l] = this.hsl;\n    return \"hsl(\" + h + \",\" + s * 100 + \"%,\" + l * 100 + \"%)\";\n  }\n\n  toRGB(): RGBColor {\n    return RGBColor.fromHSL(...this.hsl);\n  }\n\n  clone(): HSLColor {\n    return new HSLColor(...this.hsl);\n  }\n}\n","import { HSLColor } from \"./HSLColor\";\nimport { NoColor } from \"./NoColor\";\n\nexport class RGBColor {\n  static readonly NO_COLOR: NoColor = \"NO_COLOR\";\n  /**\n   * @param h Degrees\n   * @param s Percent\n   * @param l Percent\n   */\n  static fromHSL(h: number, s: number, l: number) {\n    if (h < 0 || h > 359) {\n      throw new RangeError(\"Hue should be between 0 and 359 inclusive\");\n    }\n    if (s < 0 || s > 1) {\n      throw new RangeError(\n        \"Saturation is a percentage and should be between 0 and 1 inclusive\"\n      );\n    }\n    if (l < 0 || l > 1) {\n      throw new RangeError(\n        \"Lightness is a percentage and should be between 0 and 1 inclusive\"\n      );\n    }\n\n    let c = (1 - Math.abs(2 * l - 1)) * s;\n    let x = c * (1 - Math.abs(((h / 60) % 2) - 1));\n    let m = l - c / 2;\n    let r = 0;\n    let g = 0;\n    let b = 0;\n\n    if (0 <= h && h < 60) {\n      r = c;\n      g = x;\n      b = 0;\n    } else if (60 <= h && h < 120) {\n      r = x;\n      g = c;\n      b = 0;\n    } else if (120 <= h && h < 180) {\n      r = 0;\n      g = c;\n      b = x;\n    } else if (180 <= h && h < 240) {\n      r = 0;\n      g = x;\n      b = c;\n    } else if (240 <= h && h < 300) {\n      r = x;\n      g = 0;\n      b = c;\n    } else if (300 <= h && h < 360) {\n      r = c;\n      g = 0;\n      b = x;\n    }\n    r = Math.round((r + m) * 255);\n    g = Math.round((g + m) * 255);\n    b = Math.round((b + m) * 255);\n\n    return new RGBColor(r, g, b);\n  }\n\n  /**\n   * @param hex A number between 0-16777215\n   */\n  static fromHex(hex: number) {\n    if (!Number.isInteger(hex))\n      throw new TypeError(`Number should be an integer, got: ${hex}`);\n    if (hex < 0 || hex > (2 ^ 24)) {\n      throw new RangeError(\"Number should be between 0-16777215 inclusive\");\n    }\n\n    const hexString = hex.toString(16);\n\n    return RGBColor.fromHexString(\"#\" + hexString);\n  }\n\n  static fromRGBString(rgbString: string) {\n    let sep = rgbString.indexOf(\",\") > -1 ? \",\" : \" \";\n    const rgbChunks = rgbString.substr(4).split(\")\")[0].split(sep);\n    const rgbValues: number[] = [];\n\n    for (let R in rgbChunks) {\n      let r = rgbChunks[R];\n      if (r.indexOf(\"%\") > -1)\n        rgbValues[R] =\n          Math.round(parseFloat(r.substr(0, r.length - 1)) / 100) * 255;\n    }\n\n    const r = rgbValues[0];\n    const g = rgbValues[1];\n    const b = rgbValues[2];\n\n    return new RGBColor(r, g, b);\n  }\n\n  static fromHexString(hexString: string) {\n    if (hexString.length !== 7) {\n      throw new TypeError(\n        \"Hex string is not 7 characters long. Got: \" + hexString\n      );\n    }\n\n    if (hexString[0] !== \"#\") {\n      throw new TypeError(\n        \"Hex color string should start with #. Got: \" + hexString[0]\n      );\n    }\n\n    const r = parseInt(\"0x\" + hexString[1] + hexString[2], 16);\n    const g = parseInt(\"0x\" + hexString[3] + hexString[4], 16);\n    const b = parseInt(\"0x\" + hexString[5] + hexString[6], 16);\n\n    return new RGBColor(r, g, b);\n  }\n\n  constructor(red: number, green: number, blue: number) {\n    this.rgb = [red, green, blue];\n  }\n\n  rgb: [number, number, number];\n\n  get r() {\n    return this.rgb[0];\n  }\n  get g() {\n    return this.rgb[1];\n  }\n  get b() {\n    return this.rgb[2];\n  }\n\n  set r(r: number) {\n    this.rgb[0] = r;\n  }\n  set g(g: number) {\n    this.rgb[1] = g;\n  }\n  set b(b: number) {\n    this.rgb[2] = b;\n  }\n\n  static Equals(a: RGBColor, b: RGBColor) {\n    const [r1, g1, b1] = a.rgb;\n    const [r2, g2, b2] = b.rgb;\n\n    return r1 === r2 && g1 === g2 && b1 === b2;\n  }\n\n  toHex() {\n    const [r, g, b] = this.rgb;\n    let rString = r.toString(16);\n    let gString = g.toString(16);\n    let bString = b.toString(16);\n\n    if (rString.length === 1)\n      rString = \"0\" + rString;\n    if (gString.length === 1)\n      gString = \"0\" + gString;\n    if (bString.length === 1)\n      bString = \"0\" + bString;\n\n    return \"#\" + rString + gString + bString;\n  }\n\n  toHSL(): HSLColor {\n    return HSLColor.fromRGB(...this.rgb);\n  }\n}\n","export const paletteColorDictionary: {\n  [key: string]: string[];\n} = {\n  c64: [\n    \"#000000\",\n    \"#FFFFFF\",\n    \"#880000\",\n    \"#AAFFEE\",\n    \"#DD8855\",\n    \"#664400\",\n    \"#FF7777\",\n    \"#333333\",\n    \"#CC44CC\",\n    \"#00CC55\",\n    \"#0000AA\",\n    \"#EEEE77\",\n    \"#777777\",\n    \"#AAFF66\",\n    \"#0088FF\",\n    \"#BBBBBB\",\n  ],\n  cga: [\n    \"#000000\",\n    \"#0000AA\",\n    \"#00AA00\",\n    \"#00AAAA\",\n    \"#555555\",\n    \"#5555FF\",\n    \"#55FF55\",\n    \"#55FFFF\",\n    \"#AA0000\",\n    \"#AA00AA\",\n    \"#AA5500\",\n    \"#AAAAAA\",\n    \"#FF5555\",\n    \"#FF55FF\",\n    \"#FFFF55\",\n    \"#FFFFFF\",\n  ],\n  teletext: [\n    \"#000000\",\n    \"#ff0000\",\n    \"#ffff00\",\n    \"#00ff00\",\n    \"#00ffff\",\n    \"#0000ff\",\n    \"#ff00ff\",\n    \"#ffffff\",\n  ],\n};\n\nexport const paletteNameDictionary = {\n  c64: \"Commodore 64\",\n  cga: \"DOS CGA/ EGA\",\n  teletext: \"Teletext\",\n} as const;\n\nexport type AvailablePalettes = keyof typeof paletteNameDictionary;\n","import { Box, Button } from \"grommet\";\nimport { Blank } from \"grommet-icons\";\nimport { useEffect, useRef } from \"react\";\nimport { RGBColor } from \"../drivers/color/src/RGBColor\";\nimport {\n  AvailablePalettes,\n  paletteColorDictionary,\n} from \"../PaletteDictionary\";\n\nexport const BodyColorPicker = ({\n  setColorAndTurnOffPicker,\n  color,\n  pickerMode,\n  pinnedColors,\n  colorHistory,\n  setColorHistory,\n  palette,\n}: {\n  pickerMode: \"history\" | \"pinned\" | \"palette\";\n  setColorHistory: (history: RGBColor[]) => void;\n  setColorAndTurnOffPicker: (color: RGBColor) => void;\n  color: RGBColor;\n  palette: AvailablePalettes;\n  pinnedColors: RGBColor[];\n  colorHistory: RGBColor[];\n}) => {\n  useAddToColorHistory(colorHistory, color, setColorHistory);\n\n  const boxRef = useRef<HTMLDivElement>(null);\n  let colors: RGBColor[] = [];\n\n  switch (pickerMode) {\n    case \"history\":\n      colors = colorHistory.slice(0, 16);\n      break;\n    case \"pinned\":\n      colors = pinnedColors;\n      break;\n    case \"palette\":\n      colors = paletteColorDictionary[palette].map((color) =>\n        RGBColor.fromHexString(color)\n      );\n  }\n\n  return (\n    <Box ref={boxRef} direction=\"row\" justify=\"stretch\" wrap overflow=\"auto\">\n      {colors.map((color, index) => (\n        <Box pad={{ right: \"xxsmall\", top: \"xxsmall\" }} key={index}>\n          <Button\n            primary\n            icon={<Blank />}\n            onClick={() => setColorAndTurnOffPicker(color)}\n            color={color.toHex()}\n            style={{ borderRadius: 0 }}\n          />\n        </Box>\n      ))}\n    </Box>\n  );\n};\n\nfunction useAddToColorHistory(\n  colorHistory: RGBColor[],\n  color: RGBColor,\n  setColorHistory: (history: RGBColor[]) => void\n) {\n  useEffect(() => {\n    if (\n      colorHistory.filter((currentColor) => {\n        return RGBColor.Equals(currentColor, color);\n      }).length !== 0\n    ) {\n      return;\n    }\n\n    let newColorHistory = [...colorHistory];\n    newColorHistory.unshift(color);\n\n    setColorHistory(newColorHistory);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [color]);\n}\n","import { TouchEvent, useEffect, useMemo, useRef } from \"react\";\nimport \"../styles/CanvasContainer.css\";\nimport { Background } from \"../Types\";\n\nexport const CanvasContainer = ({\n  onCanvasCreated,\n  onTouchEvent,\n  pixelDimensions,\n  background,\n}: {\n  pixelDimensions: number;\n  onCanvasCreated: (canvas: HTMLCanvasElement) => void;\n  onTouchEvent: (\n    canvas: HTMLCanvasElement,\n    touchEvent: TouchEvent<HTMLCanvasElement>\n  ) => void;\n  background: Background;\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (canvas) {\n      onCanvasCreated(canvas);\n    }\n  }, [onCanvasCreated]);\n\n  const onInnerTouchEvent = (event: TouchEvent<HTMLCanvasElement>) => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    onTouchEvent(canvas, event);\n  };\n\n  const backgroundStyle = useMemo(\n    () => getBackgroundStyle(background, pixelDimensions),\n    [background, pixelDimensions]\n  );\n  const backgroundClass = useMemo(() => getBackgroundClass(background), [\n    background,\n  ]);\n\n  return (\n    <canvas\n      className={`CanvasContainer ${backgroundClass}`}\n      style={backgroundStyle}\n      ref={canvasRef}\n      width={pixelDimensions}\n      height={pixelDimensions}\n      onTouchEnd={onInnerTouchEvent}\n      onTouchMove={onInnerTouchEvent}\n    />\n  );\n};\n\nconst getBackgroundClass = (background: Background) => {\n  switch (background.type) {\n    case \"checkerboard\":\n      return \"CheckerboardBackground\";\n    case \"color\":\n      return \"ColorBackground\";\n    case \"image\":\n      return \"ImageBackground\";\n  }\n};\n\nconst getBackgroundStyle = (\n  background: Background,\n  pixelDimensions: number\n) => {\n  switch (background.type) {\n    case \"checkerboard\":\n      return {\n        backgroundSize: `${100 / pixelDimensions / 2}%`,\n      };\n    case \"color\":\n      return {\n        backgroundColor: background.color.toHex(),\n      };\n    case \"image\":\n      return {\n        backgroundColor: background.color.toHex(),\n        backgroundImage: `url(${background.image?.src})`,\n        backgroundSize: background.size,\n      };\n  }\n};\n","import { useEffect, useRef } from \"react\";\nimport \"../styles/Grid.css\";\n\nexport type GridMode = \"dots\" | \"lines\" | \"off\";\nexport const Grid = ({\n  pixelDimensions,\n  rootCanvas,\n  mode,\n}: {\n  mode: \"lines\" | \"dots\" | \"off\";\n  pixelDimensions: number;\n  rootCanvas: HTMLCanvasElement;\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  useEffect(() => {\n    if (!mode) return;\n    const canvas = canvasRef.current;\n    const context = canvas?.getContext(\"2d\");\n\n    if (!context || !canvas) return;\n\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    context.strokeStyle = \"lightgrey\";\n    context.lineWidth = 1;\n    const xIncrement = canvas.width / pixelDimensions;\n    const yIncrement = canvas.height / pixelDimensions;\n\n    if (mode === \"lines\") {\n      drawLines(context, xIncrement, yIncrement, pixelDimensions);\n    } else {\n      drawDots(context, xIncrement, yIncrement, pixelDimensions);\n    }\n\n    return () => {\n      context.clearRect(0, 0, canvas.width, canvas.height);\n    };\n  });\n\n  return (\n    <canvas\n      style={{ display: mode === \"off\" ? \"none\" : \"unset\" }}\n      ref={canvasRef}\n      key={pixelDimensions}\n      className=\"Grid\"\n      width={rootCanvas.clientWidth}\n      height={rootCanvas.clientHeight}\n    />\n  );\n};\nfunction drawDots(\n  context: CanvasRenderingContext2D,\n  xIncrement: number,\n  yIncrement: number,\n  pixelDimensions: number\n) {\n  for (let xIndex = 0; xIndex <= pixelDimensions; xIndex++) {\n    for (let yIndex = 0; yIndex <= pixelDimensions; yIndex++) {\n      const xPosition = xIncrement * xIndex;\n      const yPosition = yIncrement * yIndex;\n      context.fillStyle = \"lightgrey\";\n      context.beginPath();\n      context.arc(xPosition, yPosition, 2, 0, Math.PI * 2, false);\n      context.fill();\n    }\n  }\n}\n\nfunction drawLines(\n  context: CanvasRenderingContext2D,\n  xIncrement: number,\n  yIncrement: number,\n  pixelDimensions: number\n) {\n  for (let xIndex = 0; xIndex < pixelDimensions; xIndex++) {\n    context.moveTo(Math.round(xIndex * xIncrement), 0);\n    context.lineTo(Math.round(xIndex * xIncrement), context.canvas.height);\n    context.stroke();\n  }\n\n  // Horizontal lines\n  for (let yIndex = 0; yIndex < pixelDimensions; yIndex++) {\n    context.moveTo(0, Math.round(yIndex * yIncrement));\n    context.lineTo(context.canvas.width, Math.round(yIndex * yIncrement));\n    context.stroke();\n  }\n}\n","import { Stack, StackProps } from \"grommet\";\nimport { useState } from \"react\";\nimport { CanvasContainer } from \"./CanvasContainer\";\nimport { ValidDimensions } from \"./DimensionPicker\";\nimport { Grid, GridMode } from \"./Grid\";\nimport { Background } from \"../Types\";\nexport const CanvasStack = ({\n  gridMode,\n  pixelDimensions,\n  background,\n  onCanvasCreated,\n  onCanvasTouch,\n  stackProps,\n}: {\n  gridMode: GridMode;\n  pixelDimensions: ValidDimensions;\n  background: Background;\n  onCanvasCreated: (canvas: HTMLCanvasElement) => void;\n  onCanvasTouch: (\n    canvas: HTMLCanvasElement,\n    event: React.TouchEvent<HTMLCanvasElement>\n  ) => void;\n  stackProps: StackProps;\n}) => {\n  const [canvas, setCanvas] = useState<HTMLCanvasElement>();\n  return (\n    <Stack {...stackProps}>\n      <CanvasContainer\n        onCanvasCreated={(canvas) => {\n          setCanvas(canvas);\n          onCanvasCreated(canvas);\n        }}\n        background={background}\n        pixelDimensions={pixelDimensions}\n        onTouchEvent={onCanvasTouch}\n      />\n\n      {canvas && (\n        <Grid\n          pixelDimensions={pixelDimensions}\n          rootCanvas={canvas}\n          mode={gridMode}\n        />\n      )}\n    </Stack>\n  );\n};\n","import { IconProps } from \"grommet-icons\";\nimport { StyledIcon } from \"grommet-icons/StyledIcon\";\n\nexport const DropperIcon = (props: IconProps) => (\n  <StyledIcon viewBox=\"0 0 6.35 6.35\" a11yTitle=\"Dropper\" {...props}>\n    <g fill=\"none\" stroke=\"#000\" strokeWidth=\".52917\">\n      <path d=\"m5.5002.60932c-.20131-.12441-.4432-.27888-.67352-.22451-.30901.072947-.38019.55202-.67352.67352-.13828.057276-.44901 0-.44901 0l-.22451.22451.22451.22451-2.9186 2.9186-.44901 1.347.22451.22451 1.347-.44901 2.9186-2.9186.22451.22451.22451-.22451s-.057276-.31073 1e-7-.44901c.1215-.29333.60057-.36451.67352-.67352.054371-.23032-.10009-.47221-.22451-.67352-.05564-.090027-.13448-.16887-.22451-.22451z\" />\n      <path d=\"m3.7042 1.5073 1.1225 1.1225\" />\n    </g>\n  </StyledIcon>\n);\n","import { IconProps } from \"grommet-icons\";\nimport { StyledIcon } from \"grommet-icons/StyledIcon\";\n\nexport const PaletteIcon = (props: IconProps) => (\n  <StyledIcon viewBox=\"0 0 6.35 6.35\" a11yTitle=\"Palette\" {...props}>\n    <path\n      xmlns=\"http://www.w3.org/2000/svg\"\n      d=\"m5.926 3.1543c-.037745.39288-.36536.56457-.83971.54908-.38933-.01271-1.2873-.15741-1.475.24331-.22247.47492.58533.95042.5725 1.4362-.011288.42757-.61548.57263-1.0208.57263-1.526 0-2.763-1.2542-2.763-2.8012 2e-8-1.5471 1.237-2.8012 2.763-2.8012 1.526 0 2.911 1.2612 2.763 2.8012z\"\n      fillOpacity=\"0\"\n      strokeWidth=\".52917\"\n    />\n    <circle cx=\"1.5769\" cy=\"3.5063\" r=\"0.3784252\" stroke=\"none\" />\n    <circle cx=\"1.8923\" cy=\"2.1661\" r=\"0.3784252\" stroke=\"none\" />\n    <circle cx=\"3.8408\" cy=\"1.7492\" r=\"0.3784252\" stroke=\"none\" />\n    <circle cx=\"2.7456\" cy=\"1.4877\" r=\"0.3784252\" stroke=\"none\" />\n  </StyledIcon>\n);\n","import { Button, ButtonProps } from \"grommet\";\nexport const HighlightableButton = ({\n  onClick,\n  isHighlighted,\n  ...props\n}: {\n  onClick: () => void;\n  isHighlighted: boolean;\n} & ButtonProps &\n  Omit<JSX.IntrinsicElements[\"button\"], \"color\">) => {\n  return (\n    <Button\n      onClick={onClick}\n      style={{\n        borderRadius: \"18px\",\n        boxShadow: isHighlighted ? \"0 0 2px 2px lightgreen\" : \"none\",\n      }}\n      {...props}\n    />\n  );\n};\n","import { Box, Button, Grid } from \"grommet\";\nimport {\n  Apps,\n  Brush,\n  Erase,\n  Grid as GridIcon,\n  History,\n  Paint,\n  Pin,\n  Redo,\n  Trash,\n  Undo,\n  Gallery,\n} from \"grommet-icons\";\nimport { DropperIcon } from \"./DropperIcon\";\nimport { GridMode } from \"./Grid\";\nimport { PaletteIcon } from \"./PaletteIcon\";\nimport { RGBColor } from \"../drivers/color/src/RGBColor\";\nimport { HighlightableButton } from \"./HighlightableButton\";\nimport { Controls, Tools } from \"../Types\";\n\nexport const ControlsBanner = ({\n  onToolChange,\n  onPickerModeClick,\n  onUndoClick,\n  onRedoClick,\n  onPaletteButtonClick,\n  onGridButtonClick,\n  onTrashClick,\n  onControlsClick,\n  gridMode,\n  color,\n  pickerMode,\n  tool,\n}: {\n  onPickerModeClick: (pickerMode: \"history\" | \"pinned\" | \"palette\") => void;\n  onUndoClick: () => void;\n  onRedoClick: () => void;\n  onPaletteButtonClick: () => void;\n  onGridButtonClick: () => void;\n  onTrashClick: () => void;\n  onToolChange: (tool: Tools) => void;\n  onControlsClick: (control: Controls) => void;\n  pickerMode: \"history\" | \"pinned\" | \"palette\";\n  tool: Tools;\n  gridMode: GridMode;\n  color: RGBColor;\n}) => {\n  const callBefore = <T extends any>(\n    callback: (arg?: T) => void,\n    control: Controls\n  ) => {\n    return (arg?: T) => {\n      onControlsClick(control);\n      if (arg) {\n        callback(arg);\n      } else {\n        callback();\n      }\n    };\n  };\n\n  return (\n    <Grid\n      fill={\"horizontal\"}\n      columns={[\"auto\", \"auto\"]}\n      rows={[\"36px\", \"36px\"]}\n      areas={[\n        { name: \"left-top\", start: [0, 0], end: [0, 0] },\n        { name: \"left-bot\", start: [0, 1], end: [0, 1] },\n        { name: \"right-top\", start: [1, 0], end: [1, 0] },\n        { name: \"right-bot\", start: [1, 1], end: [1, 1] },\n      ]}\n      gap=\"xsmall\"\n      pad={{ bottom: \"small\" }}\n    >\n      <Box gridArea=\"left-top\" direction=\"row\" gap=\"xsmall\">\n        <HighlightableButton\n          primary\n          onClick={callBefore(() => onToolChange(\"paint\"), \"paint\")}\n          isHighlighted={tool === \"paint\"}\n          icon={<Brush />}\n          color={color.toHex()}\n        />\n        <HighlightableButton\n          onClick={callBefore(() => onToolChange(\"eraser\"), \"eraser\")}\n          isHighlighted={tool === \"eraser\"}\n          icon={<Erase />}\n        />\n        <HighlightableButton\n          primary\n          onClick={callBefore(() => onToolChange(\"fill\"), \"fill\")}\n          isHighlighted={tool === \"fill\"}\n          icon={<Paint />}\n          color={color.toHex()}\n        />\n        <Button\n          onClick={callBefore(onPaletteButtonClick, \"palette\")}\n          icon={<PaletteIcon />}\n          focusIndicator={false}\n        />\n        <HighlightableButton\n          onClick={callBefore(() => onToolChange(\"dropper\"), \"dropper\")}\n          isHighlighted={tool === \"dropper\"}\n          icon={<DropperIcon />}\n        />\n      </Box>\n      <Box gridArea=\"left-bot\" direction=\"row\" gap=\"xsmall\">\n        <HighlightableButton\n          icon={<History />}\n          onClick={callBefore(() => onPickerModeClick(\"history\"), \"history\")}\n          isHighlighted={pickerMode === \"history\"}\n        />\n        <HighlightableButton\n          icon={<Pin />}\n          onClick={callBefore(() => onPickerModeClick(\"pinned\"), \"pinned\")}\n          isHighlighted={pickerMode === \"pinned\"}\n        />\n\n        <HighlightableButton\n          icon={<Gallery />}\n          onClick={callBefore(\n            () => onPickerModeClick(\"palette\"),\n            \"paletteColor\"\n          )}\n          isHighlighted={pickerMode === \"palette\"}\n        />\n      </Box>\n      <Box gridArea=\"right-top\" direction=\"row\" justify=\"end\" gap=\"xsmall\">\n        <Button\n          size=\"small\"\n          icon={<Undo />}\n          onClick={callBefore(onUndoClick, \"undo\")}\n          focusIndicator={false}\n        />\n        <Button\n          icon={<Redo />}\n          onClick={callBefore(onRedoClick, \"redo\")}\n          focusIndicator={false}\n        />\n      </Box>\n      <Box gridArea=\"right-bot\" direction=\"row\" justify=\"end\" gap=\"xsmall\">\n        <Button\n          onClick={callBefore(onTrashClick, \"trash\")}\n          icon={<Trash />}\n          focusIndicator={false}\n        />\n        <HighlightableButton\n          onClick={callBefore(onGridButtonClick, \"grid\")}\n          isHighlighted={gridMode !== \"off\"}\n          icon={gridMode === \"dots\" ? <Apps /> : <GridIcon />}\n        />\n      </Box>\n    </Grid>\n  );\n};\n","import { useEffect } from \"react\";\n\nexport const useTimeout = (callback: Function, delay: number) => {\n  useEffect(() => {\n    const id = setTimeout(callback, delay);\n    return () => clearTimeout(id);\n  }, [callback, delay]);\n};\n","import { Box, Layer, Text } from \"grommet\";\nimport { useState } from \"react\";\nimport \"../styles/ControlsFeedback.css\";\nimport { Controls } from \"../Types\";\nimport { useTimeout } from \"../hooks/useTimeout\";\n\nconst controlToFeedback: Record<Controls, string> = {\n  dropper: \"Dropper\",\n  eraser: \"Eraser\",\n  fill: \"Fill\",\n  grid: \"Grid\",\n  history: \"Recent colors\",\n  paint: \"Pixel brush\",\n  paletteColor: \"Palette colors\",\n  palette: \"Palette\",\n  pinned: \"Pinned colors\",\n  redo: \"Redo\",\n  undo: \"Undo\",\n  trash: \"Clear canvas\",\n};\nexport const ControlsFeedback = ({\n  onClose,\n  control,\n}: {\n  onClose: () => void;\n  control: Controls;\n}) => {\n  const [opacity, setOpacity] = useState(1);\n  useTimeout(onClose, 800);\n  useTimeout(() => setOpacity(0), 400);\n  return (\n    <Layer\n      position=\"center\"\n      responsive={false}\n      onClickOutside={onClose}\n      modal={false}\n      animation=\"none\"\n      className=\"ControlsFeedback\"\n      style={{ opacity, backgroundColor: \"rgba(255, 255, 255, 0.6)\" }}\n    >\n      <Box pad={{ horizontal: \"small\", vertical: \"xsmall\" }}>\n        <Text style={{ color: \"black\" }}>{controlToFeedback[control]}</Text>\n      </Box>\n    </Layer>\n  );\n};\n","/* eslint-disable jsx-a11y/anchor-has-content */\nimport { Button } from \"grommet\";\nimport { Share } from \"grommet-icons\";\nimport { useRef } from \"react\";\n\nexport const SaveButton = ({ canvas }: { canvas: HTMLCanvasElement }) => {\n  const anchorRef = useRef<HTMLAnchorElement>(null);\n  const onShareClick = async (event: React.MouseEvent<HTMLButtonElement>) => {\n    const fullScaleCanvas = drawToHigherResolutionCanvas(canvas);\n\n    try {\n      const blob = await new Promise<Blob>((resolve, reject) => {\n        fullScaleCanvas.toBlob((maybeBlob) => {\n          if (maybeBlob) {\n            resolve(maybeBlob);\n          } else {\n            reject(new Error(\"Unable to convert canvas to blob\"));\n          }\n        }, \"image/png\");\n      });\n\n      if (document.location.protocol !== \"https:\") {\n        throw new Error(\"Could not share. Page is not HTTPS.\");\n      }\n\n      if (navigator.share === undefined) {\n        throw new Error(\"Share unsupported in this browser\");\n      }\n\n      const files = Object.freeze([\n        new File([blob], \"my-pixel-art.png\", { type: blob.type }),\n      ]);\n\n      if (!(navigator.canShare && navigator.canShare({ files }))) {\n        throw new Error(\"File sharing unsupported in this browser\");\n      }\n\n      await navigator\n        .share({\n          title: \"My pixel art\",\n          files,\n        })\n        .catch((error: Error) => {\n          if (error.name === \"AbortError\") {\n            console.debug(\"User cancelled share\");\n            return;\n          }\n          throw error;\n        });\n    } catch (error) {\n      console.debug(\"Could not use share api, using image download\");\n      console.debug(error);\n      const image = fullScaleCanvas.toDataURL(\"image/png\");\n      if (anchorRef.current) {\n        anchorRef.current.href = image;\n        anchorRef.current.click();\n      }\n    }\n  };\n  return (\n    <>\n      <Button icon={<Share />} onClick={onShareClick} focusIndicator={false} />\n      <a\n        ref={anchorRef}\n        href=\"/\"\n        style={{ display: \"none\" }}\n        download=\"my-pixel-art.png\"\n      />\n    </>\n  );\n};\n\nfunction drawToHigherResolutionCanvas(canvas: HTMLCanvasElement) {\n  const fullScaleCanvas = document.createElement(\"canvas\");\n  fullScaleCanvas.width = 1024;\n  fullScaleCanvas.height = 1024;\n  const context = fullScaleCanvas.getContext(\"2d\")!;\n  context.imageSmoothingEnabled = false;\n  context.drawImage(\n    canvas,\n    0,\n    0,\n    fullScaleCanvas.width,\n    fullScaleCanvas.height\n  );\n  return fullScaleCanvas;\n}\n","import { Box, Button, Grid } from \"grommet\";\nimport { Actions, Add } from \"grommet-icons\";\nimport { SaveButton } from \"./SaveButton\";\nexport const Footer = ({\n  canvas,\n  onAddButtonClicked,\n  setSettingsMenuShown,\n  gridArea,\n}: {\n  canvas: HTMLCanvasElement;\n  onAddButtonClicked: () => void;\n  setSettingsMenuShown: (value: boolean) => void;\n} & { gridArea: string }) => {\n  return (\n    <Box gridArea={gridArea} pad={{ left: \"small\", right: \"small\" }}>\n      <Grid\n        columns={{\n          count: 3,\n          size: [\"auto\", \"auto\", \"auto\"],\n        }}\n        fill\n        gap=\"small\"\n      >\n        <Box align=\"start\">\n          <Button\n            icon={<Actions />}\n            onClick={() => setSettingsMenuShown(true)}\n            focusIndicator={false}\n          />\n        </Box>\n        <Box align=\"center\">\n          <Button\n            icon={<Add />}\n            onClick={onAddButtonClicked}\n            focusIndicator={false}\n          />\n        </Box>\n        <Box align=\"end\">{<SaveButton canvas={canvas} />}</Box>\n      </Grid>\n    </Box>\n  );\n};\n","\nexport class KeyPairMap<KeyA, KeyB, Value> implements Map<[KeyA, KeyB], Value> {\n  constructor(keyPairMap?: KeyPairMap<KeyA, KeyB, Value>) {\n    if (!keyPairMap)\n      return;\n\n    for (let [[keyA, keyB], value] of keyPairMap) {\n      this.set([keyA, keyB], value);\n    }\n  }\n\n  private map = new Map<KeyA, Map<KeyB, Value>>();\n\n  clear(): void {\n    this.map.clear();\n  }\n\n  delete([keyA, keyB]: [KeyA, KeyB]): boolean {\n    return this.map.get(keyA)?.delete(keyB) || false;\n  }\n\n  clone(): KeyPairMap<KeyA, KeyB, Value> {\n    return new KeyPairMap(this);\n  }\n\n  forEach(\n    callbackfn: (\n      value: Value,\n      key: [KeyA, KeyB],\n      map: Map<[KeyA, KeyB], Value>\n    ) => void,\n    thisArg?: any\n  ): void {\n    const refMap = this.toRefMap();\n\n    refMap.forEach(callbackfn, thisArg);\n  }\n\n  private toRefMap() {\n    const tempMap = new Map<[KeyA, KeyB], Value>();\n    this.map.forEach((innerMap, keyA, outerMap) => {\n      innerMap.forEach((value, keyB, innerMap) => {\n        const keys = [keyA, keyB] as [KeyA, KeyB];\n        tempMap.set(keys, value);\n      });\n    });\n    return tempMap;\n  }\n\n  get([keyA, keyB]: [KeyA, KeyB]): Value | undefined {\n    return this.map.get(keyA)?.get(keyB);\n  }\n\n  has([keyA, keyB]: [KeyA, KeyB]): boolean {\n    return this.map.get(keyA)?.has(keyB) || false;\n  }\n\n  set([keyA, keyB]: [KeyA, KeyB], value: Value): this {\n    const hasKeyA = this.map.has(keyA);\n\n    if (!hasKeyA) {\n      this.map.set(keyA, new Map());\n    }\n    this.map.get(keyA)!.set(keyB, value);\n\n    return this;\n  }\n\n  get size() {\n    return this.toRefMap().size;\n  }\n\n  [Symbol.iterator](): IterableIterator<[[KeyA, KeyB], Value]> {\n    return this.toRefMap()[Symbol.iterator]();\n  }\n\n  entries(): IterableIterator<[[KeyA, KeyB], Value]> {\n    return this.toRefMap().entries();\n  }\n\n  keys(): IterableIterator<[KeyA, KeyB]> {\n    return this.toRefMap().keys();\n  }\n\n  values(): IterableIterator<Value> {\n    return this.toRefMap().values();\n  }\n\n  toString(): string {\n    let lines = [];\n\n    for (let [key, value] of this) {\n      lines.push(`${key[0]}, ${key[1]}, ${value}`);\n    }\n\n    return lines.join(\"\\n\");\n  }\n  [Symbol.toStringTag]: string;\n}\n","import { NoColor, RGBColor } from \"../../color\";\nimport { getRelativeClickPosition } from \"./getRelativeClickPosition\";\nimport { KeyPairMap } from \"./KeyPairMap\";\n\nexport class PaintCanvas {\n  static DrawToCanvas(paintCanvas: PaintCanvas, canvas: HTMLCanvasElement) {\n    const context = canvas.getContext(\"2d\");\n    if (!context) throw new Error(\"Could not get context for canvas\");\n    paintCanvas.forEach(([x, y], color) => {\n      if (color === RGBColor.NO_COLOR) {\n        context.clearRect(x, y, 1, 1);\n        return;\n      }\n\n      context.fillStyle = color.toHex();\n      context.fillRect(x, y, 1, 1);\n    });\n  }\n\n  static AreDimensionsCompatible(\n    paintCanvas: PaintCanvas,\n    canvas: HTMLCanvasElement\n  ) {\n    const { width, height } = canvas;\n    const dimension = paintCanvas.dimension();\n\n    if (width !== height) {\n      return false;\n    }\n\n    if (dimension !== width) {\n      return false;\n    }\n\n    return true;\n  }\n\n  drawToCanvas() {\n    if (this.canvas === undefined) {\n      throw new Error(\"Cannot draw to canvas, no canvas set\");\n    }\n\n    PaintCanvas.DrawToCanvas(this, this.canvas);\n  }\n\n  tryDrawToCanvas(): boolean {\n    try {\n      this.drawToCanvas();\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  setCanvas(canvas: HTMLCanvasElement) {\n    if (!PaintCanvas.AreDimensionsCompatible(this, canvas)) {\n      throw new RangeError(\n        `PaintCanvas and HTMLCanvas should be square and the same dimensions. Got PaintCanvas: ${this.dimension()} canvas: ${\n          canvas.width\n        }x${canvas.height}`\n      );\n    }\n\n    this.canvas = canvas;\n  }\n\n  hasCanvas(): boolean {\n    return this.canvas !== undefined;\n  }\n\n  getCanvas(): HTMLCanvasElement | undefined {\n    return this.canvas;\n  }\n\n  private pixelMap = new KeyPairMap<number, number, RGBColor | NoColor>();\n\n  getPixelMap() {\n    return this.pixelMap;\n  }\n\n  setPixelMap(map: KeyPairMap<number, number, RGBColor | \"NO_COLOR\">) {\n    if (map.size !== this.pixelMap.size) {\n      throw new RangeError(\n        \"Cannot set pixel map. Pixel maps are not the same dimensions\"\n      );\n    }\n    this.pixelMap = map.clone();\n  }\n\n  setPixelsFromImage(image: HTMLImageElement) {\n    const canvas = document.createElement(\"canvas\");\n    const context = canvas.getContext(\"2d\");\n    if (!context) throw new Error(\"Could not get context for canvas\");\n\n    canvas.width = image.naturalWidth;\n    canvas.height = image.naturalHeight;\n    context.drawImage(image, 0, 0);\n\n    this.setPixelsFromCanvas(canvas);\n  }\n\n  setPixelsFromCanvas(canvas: HTMLCanvasElement) {\n    const context = canvas.getContext(\"2d\");\n    if (!context) throw new Error(\"Could not get context for canvas\");\n\n    const xIntervals = canvas.width / this.dimension();\n    const yIntervals = canvas.height / this.dimension();\n    this.mutableMap(([x, y]) => {\n      const { data } = context.getImageData(\n        x * xIntervals,\n        y * yIntervals,\n        1,\n        1\n      );\n\n      const [r, g, b, a] = data;\n      const color = a === 0 ? RGBColor.NO_COLOR : new RGBColor(r, g, b);\n      return color;\n    });\n  }\n\n  clear() {\n    this.mutableMap(() => RGBColor.NO_COLOR);\n  }\n\n  setColorAt(x: number, y: number, color: RGBColor | NoColor) {\n    const isPixelInRange = this.pixelMap.has([x, y]);\n\n    if (!isPixelInRange) {\n      throw RangeError(`Pixel at ${x},${y} does not exist`);\n    }\n\n    this.pixelMap.set([x, y], color);\n  }\n\n  getColorAt(x: number, y: number): RGBColor | NoColor {\n    const maybeColor = this.pixelMap.get([x, y]);\n\n    if (maybeColor === undefined)\n      throw RangeError(`Pixel at ${x},${y} does not exist`);\n\n    return maybeColor;\n  }\n\n  map<T>(\n    callbackfn: (coord: [x: number, y: number], color: RGBColor | NoColor) => T\n  ): T[] {\n    const results = new Array<T>();\n    for (let [key, value] of this.pixelMap.entries()) {\n      const elementResult = callbackfn(key, value);\n      results.push(elementResult);\n    }\n\n    return results;\n  }\n\n  mutableMap(\n    callbackfn: (\n      coord: [x: number, y: number],\n      color: RGBColor | NoColor\n    ) => RGBColor | NoColor\n  ) {\n    for (let [key, value] of this.pixelMap.entries()) {\n      const result = callbackfn(key, value);\n      this.pixelMap.set(key, result);\n    }\n  }\n\n  forEach(\n    callbackfn: (\n      coord: [x: number, y: number],\n      color: RGBColor | NoColor\n    ) => void\n  ) {\n    for (let [key, value] of this.pixelMap.entries()) {\n      callbackfn(key, value);\n    }\n  }\n  private canvas?: HTMLCanvasElement;\n\n  constructor(dimension: number) {\n    for (let x = 0; x < dimension; x++) {\n      for (let y = 0; y < dimension; y++) {\n        const keys = [x, y] as [number, number];\n        const color = RGBColor.NO_COLOR;\n        this.pixelMap.set(keys, color);\n      }\n    }\n  }\n\n  dimension(): number {\n    return Math.sqrt(this.pixelMap.size);\n  }\n\n  touchEvent(\n    touch: { clientX: number; clientY: number },\n    target: HTMLElement,\n    color: RGBColor | NoColor\n  ) {\n    const { quantX, quantY } = this.touchToCoords(touch, target);\n\n    const currentColor = this.getColorAt(quantX, quantY);\n\n    if (color === \"NO_COLOR\" && currentColor === \"NO_COLOR\") {\n      return;\n    }\n\n    if (color === \"NO_COLOR\" && currentColor !== \"NO_COLOR\") {\n      this.setColorAt(quantX, quantY, color);\n      return;\n    }\n\n    if (color !== \"NO_COLOR\" && currentColor === \"NO_COLOR\") {\n      this.setColorAt(quantX, quantY, color);\n      return;\n    }\n\n    if (color !== \"NO_COLOR\" && currentColor !== \"NO_COLOR\") {\n      if (!RGBColor.Equals(color, currentColor)) {\n        this.setColorAt(quantX, quantY, color);\n      }\n    }\n  }\n\n  touchToCoords(\n    touch: { clientX: number; clientY: number },\n    target: HTMLElement\n  ) {\n    const { relativeX, relativeY } = getRelativeClickPosition(touch, target);\n    const scaledX = relativeX * this.dimension();\n    const scaledY = relativeY * this.dimension();\n    const quantX = Math.floor(scaledX);\n    const quantY = Math.floor(scaledY);\n    return { quantX, quantY };\n  }\n}\n","export function getRelativeClickPosition(\n  touch: { clientX: number; clientY: number },\n  target: HTMLElement\n): { relativeX: number; relativeY: number } {\n  const screenX = touch.clientX;\n  const screenY = touch.clientY;\n  const rect = (target as HTMLElement).getBoundingClientRect();\n\n  const clip = (value: number, min: number, max: number) =>\n    Math.min(max, Math.max(value, min));\n\n  const clippedX = clip(screenX - rect.left, 0, rect.width - 1);\n  const clippedY = clip(screenY - rect.top, 0, rect.height - 1);\n\n  const relativeX = clippedX / rect.width;\n  const relativeY = clippedY / rect.height;\n  return { relativeX: relativeX, relativeY: relativeY };\n}\n","import { UndoBuffer } from \"./UndoBuffer\";\n\n\nexport class UndoRedoBuffer<T> extends UndoBuffer<T> {\n  private redoBuffer = new Array<T>();\n\n  undo(): T {\n    const maybeTop = this.top();\n    if (maybeTop !== undefined && this.getBufferLength() > 1) {\n      this.redoBuffer.push(maybeTop);\n    }\n\n    const previousPoint = super.undo();\n    return previousPoint;\n  }\n\n  addCurrent(value: T) {\n    this.redoBuffer = [];\n    super.addCurrent(value);\n  }\n\n  getUndoSize() {\n    return super.getUndoSize();\n  }\n\n  getRedoSize() {\n    return this.redoBuffer.length;\n  }\n\n  redoOne(): T | undefined {\n    const redid = this.redoBuffer.pop();\n    if (redid !== undefined) {\n      super.addCurrent(redid);\n    }\n\n    return redid;\n  }\n\n  clear() {\n    this.redoBuffer = [];\n    super.clear();\n  }\n}\n","\nexport class UndoBuffer<T> {\n  buffer: T[];\n\n  constructor(private base: T, private maxSize?: number) {\n    this.buffer = [base];\n  }\n\n  top() {\n    return this.buffer[this.buffer.length - 1] as T | undefined;\n  }\n\n  undo() {\n    this.buffer.pop();\n    const maybeReverseState = this.buffer[this.buffer.length - 1] as T |\n      undefined;\n    if (maybeReverseState) {\n      return maybeReverseState;\n    } else {\n      this.buffer = [this.base];\n      return this.base;\n    }\n  }\n\n  addCurrent(value: T) {\n    this.buffer.push(value);\n\n    if (this.maxSize && this.maxSize < this.buffer.length) {\n      this.buffer = this.buffer.slice(-this.maxSize - 2);\n    }\n  }\n\n  getUndoSize() {\n    return Math.max(this.buffer.length - 2, 0);\n  }\n\n  getBufferLength() {\n    return this.buffer.length;\n  }\n\n  clear() {\n    this.buffer = [];\n  }\n}\n","import { NoColor } from \"../../color\";\nimport { RGBColor } from \"../../color/src/RGBColor\";\nimport { KeyPairMap } from \"./KeyPairMap\";\nimport { PaintCanvas } from \"./PaintCanvas\";\nimport { UndoRedoBuffer } from \"./UndoRedoBuffer\";\n\nexport class UndoablePaintCanvas extends PaintCanvas {\n  static AreColorsEqual = (\n    colorA: RGBColor | NoColor,\n    colorB: RGBColor | NoColor\n  ) => {\n    if (colorA === \"NO_COLOR\" && colorB === \"NO_COLOR\") {\n      return true;\n    }\n\n    if (colorA === \"NO_COLOR\" && colorB !== \"NO_COLOR\") {\n      return false;\n    }\n\n    if (colorA !== \"NO_COLOR\" && colorB === \"NO_COLOR\") {\n      return false;\n    }\n\n    if (colorA !== \"NO_COLOR\" && colorB !== \"NO_COLOR\") {\n      if (RGBColor.Equals(colorA, colorB)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  undoBuffer: UndoRedoBuffer<KeyPairMap<number, number, RGBColor | \"NO_COLOR\">>;\n  constructor(dimension: number) {\n    super(dimension);\n\n    this.undoBuffer = new UndoRedoBuffer<\n      KeyPairMap<number, number, RGBColor | NoColor>\n    >(this.getPixelMap().clone());\n  }\n\n  mutableMap(\n    callbackfn: (\n      coord: [x: number, y: number],\n      color: RGBColor | NoColor\n    ) => RGBColor | NoColor\n  ) {\n    super.mutableMap(callbackfn);\n    this.undoBuffer.addCurrent(this.getPixelMap().clone());\n  }\n\n  setColorAt(x: number, y: number, color: RGBColor | NoColor) {\n    super.setColorAt(x, y, color);\n    this.undoBuffer.addCurrent(this.getPixelMap().clone());\n  }\n\n  undo() {\n    const undo = this.undoBuffer.undo();\n    this.setPixelMap(undo);\n  }\n\n  redo() {\n    const redo = this.undoBuffer.redoOne();\n    if (redo !== undefined) {\n      this.setPixelMap(redo);\n    }\n  }\n\n  fillWithColor(x: number, y: number, fillColor: RGBColor | NoColor) {\n    const startColor = this.getColorAt(x, y);\n\n    const visited = new KeyPairMap<number, number, boolean>();\n    this.getPixelMap()\n      .clone()\n      .forEach((color, [x, y]) => {\n        visited.set([x, y], false);\n      });\n\n    const didPixelsChange = this.floodFill(\n      x,\n      y,\n      fillColor,\n      startColor,\n      visited\n    );\n\n    if (didPixelsChange) {\n      this.undoBuffer.addCurrent(this.getPixelMap().clone());\n    }\n  }\n  /**\n   *\n   * @param x\n   * @param y\n   * @param fillColor The requested color to fill with\n   * @param startColor The current color of the cell requested to be filled from\n   * @param visited A map of the board indicating if that cell has been checked already\n   */\n  private floodFill(\n    x: number,\n    y: number,\n    fillColor: RGBColor | NoColor,\n    startColor: RGBColor | NoColor,\n    visited: KeyPairMap<number, number, boolean>\n  ): boolean {\n    const isCellOnBoard = !this.cellExists(x, y);\n    if (isCellOnBoard) return false;\n\n    const hasCellAlreadyBeenVisited = visited.get([x, y]) === true;\n    if (hasCellAlreadyBeenVisited) return false;\n\n    const cellColor = this.getColorAt(x, y);\n    const doesCellMatchStartColor = UndoablePaintCanvas.AreColorsEqual(\n      cellColor,\n      startColor\n    );\n    if (!doesCellMatchStartColor) return false;\n\n    const doesCellMatchFillColor = UndoablePaintCanvas.AreColorsEqual(\n      cellColor,\n      fillColor\n    );\n\n    visited.set([x, y], true);\n    if (doesCellMatchFillColor) {\n      return false;\n    }\n\n    super.setColorAt(x, y, fillColor);\n\n    const edges = [\n      [x, y + 1],\n      [x, y - 1],\n      [x + 1, y],\n      [x - 1, y],\n    ];\n\n    edges.forEach(([x, y]) =>\n      this.floodFill(x, y, fillColor, startColor, visited)\n    );\n\n    return true;\n  }\n\n  private cellExists = (x: number, y: number) => this.getPixelMap().has([x, y]);\n}\n","import { Box, Button, Heading, Layer } from \"grommet\";\nimport { Close } from \"grommet-icons\";\nimport { PropsWithChildren } from \"react\";\n\nexport const Modal = ({\n  onClose,\n  children,\n  heading,\n}: PropsWithChildren<{ onClose: () => void; heading: string }>) => {\n  return (\n    <Layer modal full=\"horizontal\" onClickOutside={onClose}>\n      <Box direction=\"row\" fill={\"horizontal\"} justify=\"between\" pad=\"small\">\n        <Heading\n          alignSelf=\"center\"\n          level=\"2\"\n          margin={{ top: \"0\", bottom: \"0\" }}\n        >\n          {heading}\n        </Heading>\n        <Box direction=\"row\" justify=\"end\">\n          <Button icon={<Close />} onClick={() => onClose()} />\n        </Box>\n      </Box>\n      <Box fill pad=\"small\">\n        <Box gap=\"small\">{children}</Box>\n      </Box>\n    </Layer>\n  );\n};\n","import { Button, Grid, Text } from \"grommet\";\nimport { Modal } from \"./Modal\";\n\nexport type ConfirmModalProps = {\n  onAccept: () => void;\n  onCancel?: () => void;\n  onClose: () => void;\n  message?: string;\n  acceptButtonText?: string;\n  cancelButtonText?: string;\n};\n\nexport const ConfirmModal = ({\n  onAccept,\n  onCancel,\n  onClose,\n  message = \"Are you sure?\",\n  cancelButtonText = \"Cancel\",\n  acceptButtonText = \"Accept\",\n}: ConfirmModalProps) => {\n  return (\n    <Modal onClose={onClose} heading={\"Confirm?\"}>\n      <Text alignSelf=\"center\">{message}</Text>\n      <Grid\n        columns={{ count: 2, size: [\"auto\", \"auto\"] }}\n        gap=\"small\"\n        pad={{ top: \"medium\", bottom: \"small\" }}\n      >\n        <Button label={cancelButtonText} onClick={onCancel} />\n        <Button\n          primary\n          label={acceptButtonText}\n          onClick={onAccept}\n          alignSelf=\"end\"\n        />\n      </Grid>\n    </Modal>\n  );\n};\n","import { FormField, Select, SelectProps } from \"grommet\";\nimport { ReactElement } from \"react\";\n\nconst validDimensions = [\n  { value: 1, label: \"1x1\" },\n  { value: 8, label: \"8x8\" },\n  { value: 10, label: \"10x10\" },\n  { value: 12, label: \"12x12\" },\n  { value: 14, label: \"14x14\" },\n  { value: 16, label: \"16x16\" },\n  { value: 18, label: \"18x18\" },\n  { value: 20, label: \"20x20\" },\n  { value: 22, label: \"22x22\" },\n  { value: 24, label: \"24x24\" },\n] as const;\n\nconst labelToValue = {\n  \"1x1\": 1,\n  \"8x8\": 8,\n  \"10x10\": 10,\n  \"12x12\": 12,\n  \"14x14\": 14,\n  \"16x16\": 16,\n  \"18x18\": 18,\n  \"20x20\": 20,\n  \"22x22\": 22,\n  \"24x24\": 24,\n} as const;\n\nconst valueToLabel = {\n  1: \"1x1\",\n  8: \"8x8\",\n  10: \"10x10\",\n  12: \"12x12\",\n  14: \"14x14\",\n  16: \"16x16\",\n  18: \"18x18\",\n  20: \"20x20\",\n  22: \"22x22\",\n  24: \"24x24\",\n} as const;\n\nconst options = [\n  \"1x1\",\n  \"8x8\",\n  \"10x10\",\n  \"12x12\",\n  \"14x14\",\n  \"16x16\",\n  \"18x18\",\n  \"20x20\",\n  \"22x22\",\n  \"24x24\",\n];\n\nexport type ValidDimensions = typeof validDimensions[number][\"value\"];\n\nexport const DimensionPicker = ({\n  dimension,\n  onDimensionChange,\n  ...props\n}: {\n  dimension: ValidDimensions;\n  onDimensionChange: (dimension: ValidDimensions) => void;\n} & Omit<SelectProps, \"options\">): ReactElement => {\n  return (\n    <FormField label=\"Canvas Pixel Dimensions\">\n      <Select\n        name=\"Select Dimensions\"\n        placeholder=\"8x8\"\n        value={valueToLabel[dimension]}\n        options={options}\n        onChange={({ option }: { option: keyof typeof labelToValue }) =>\n          onDimensionChange(labelToValue[option])\n        }\n        {...props}\n      />\n    </FormField>\n  );\n};\n","import { Button } from \"grommet\";\nimport { useRef } from \"react\";\n\nexport const LoadButton = ({\n  setLoadedImage,\n  onLoadStart,\n}: {\n  setLoadedImage: (image: HTMLImageElement) => void;\n  onLoadStart?: (image: Promise<HTMLImageElement>) => void;\n}) => {\n  const ref = useRef<HTMLInputElement>(null);\n  return (\n    <>\n      <Button\n        size=\"small\"\n        label=\"Choose Image\"\n        onClick={() => {\n          const input = ref.current;\n          if (!input) return;\n          input.click();\n        }}\n      />\n\n      <input\n        ref={ref}\n        style={{ display: \"none\" }}\n        onChange={async (event) => {\n          const imagePromise = new Promise<HTMLImageElement>(\n            (resolve, reject) => {\n              if (!event.target.files || !event.target.files[0]) return;\n              const imageUrl = URL.createObjectURL(event.target.files![0]);\n              const image = new Image();\n              image.src = imageUrl;\n              image.onload = () => resolve(image);\n            }\n          );\n          onLoadStart?.(imagePromise);\n          const image = await imagePromise;\n          setLoadedImage(image);\n        }}\n        type=\"file\"\n        accept=\"image/*\"\n      />\n    </>\n  );\n};\n","import { Box, Button, Grid, Text } from \"grommet\";\nimport { useEffect, useState } from \"react\";\nimport {\n  DimensionPicker,\n  ValidDimensions,\n} from \"../components/DimensionPicker\";\nimport { LoadButton } from \"../components/LoadButton\";\nimport { Modal } from \"../modals/Modal\";\n\nexport const NewPageModal = ({\n  currentDimension,\n  onCancel,\n  onCreateNew,\n}: {\n  currentDimension: ValidDimensions;\n  onCancel: () => void;\n  onCreateNew: (\n    dimension: ValidDimensions,\n    loadedImage?: HTMLImageElement\n  ) => void;\n}) => {\n  const [loadedImage, setLoadedImage] = useState<HTMLImageElement>();\n  const [loading, setLoading] = useState(false);\n  const [dimension, setDimension] = useState<ValidDimensions>(currentDimension);\n\n  useEffect(() => {\n    setDimension(currentDimension);\n  }, [currentDimension]);\n\n  return (\n    <Modal onClose={onCancel} heading=\"New Drawing\">\n      <DimensionPicker onDimensionChange={setDimension} dimension={dimension} />\n      <Box\n        direction=\"row\"\n        gap=\"small\"\n        fill=\"horizontal\"\n        justify=\"between\"\n        pad={{ left: \"8px\" }}\n      >\n        <Text alignSelf=\"center\">Upload Image (optional)</Text>\n        <LoadButton\n          setLoadedImage={setLoadedImage}\n          onLoadStart={async (promise) => {\n            setLoading(true);\n            await promise;\n            setLoading(false);\n          }}\n        />\n      </Box>\n\n      <Grid\n        columns={{ count: 2, size: [\"auto\", \"auto\"] }}\n        gap=\"small\"\n        pad={{ top: \"medium\", bottom: \"small\" }}\n      >\n        <Button label=\"Cancel\" onClick={onCancel} />\n\n        <Button\n          primary\n          disabled={loading}\n          label={loading ? \"Loading Image\" : \"Create New\"}\n          onClick={() => onCreateNew(dimension, loadedImage)}\n        />\n      </Grid>\n    </Modal>\n  );\n};\n","import { Select } from \"grommet\";\nimport { ReactElement } from \"react\";\nimport { AvailablePalettes, paletteNameDictionary } from \"../PaletteDictionary\";\n\nconst options = [\"Commodore 64\", \"DOS CGA/ EGA\", \"Teletext\"];\n\nconst labelToValue = {\n  \"Commodore 64\": \"c64\",\n  \"DOS CGA/ EGA\": \"cga\",\n  Teletext: \"teletext\",\n} as const;\n\nexport const PalettePicker = ({\n  palette,\n  onPaletteChange,\n}: {\n  palette: AvailablePalettes;\n  onPaletteChange: (palette: AvailablePalettes) => void;\n}): ReactElement => {\n  const possiblePalettes = paletteNameDictionary;\n  return (\n    <Select\n      name=\"Select Palette\"\n      placeholder={possiblePalettes.c64}\n      value={paletteNameDictionary[palette]}\n      options={options}\n      onChange={({ option }: { option: keyof typeof labelToValue }) =>\n        onPaletteChange(labelToValue[option])\n      }\n    />\n  );\n};\n","import { Box, Button } from \"grommet\";\nimport { Pin } from \"grommet-icons\";\nimport { useState } from \"react\";\nimport { RGBColor } from \"../drivers/color/src/RGBColor\";\nimport { useLongPress } from \"../hooks/useLongPress\";\nimport { Modal } from \"./Modal\";\nimport {\n  AvailablePalettes,\n  paletteColorDictionary,\n} from \"../PaletteDictionary\";\nimport { PalettePicker } from \"../components/PalettePicker\";\nexport const PaletteModal = ({\n  onCancel,\n  setColor,\n  palette = \"cga\",\n  pinnedColors = [],\n  setPinnedColors,\n  setPalette,\n}: {\n  onCancel: () => void;\n  setColor: (color: RGBColor) => void;\n  palette?: AvailablePalettes;\n  pinnedColors?: RGBColor[];\n  setPalette?: (palette: AvailablePalettes) => void;\n  setPinnedColors?: (colors: RGBColor[]) => void;\n}) => {\n  const [innerPalette, setInnerPalette] = useState<AvailablePalettes>(palette);\n  const paletteColors = paletteColorDictionary[innerPalette];\n  const selectedPalette = paletteColors.map(RGBColor.fromHexString);\n\n  const onPaletteChange = (palette: AvailablePalettes) => {\n    setInnerPalette(palette);\n    setPalette?.(palette);\n  };\n\n  const { onPressDown, onPressUp } = useLongPress(\n    (event) => {\n      if (!setPinnedColors) return;\n      const index = getButtonIndex(event);\n      if (index === undefined) return;\n\n      const color = selectedPalette[index];\n\n      const isPinned = !!pinnedColors.find((pinned) =>\n        RGBColor.Equals(pinned, color)\n      );\n\n      if (isPinned) {\n        const currentPinnedColors = [...pinnedColors].filter(\n          (pinned) => !RGBColor.Equals(color, pinned)\n        );\n        setPinnedColors(currentPinnedColors);\n      } else {\n        const currentPinnedColors = [...pinnedColors];\n        currentPinnedColors.push(color);\n        setPinnedColors(currentPinnedColors);\n      }\n    },\n    500,\n    (event) => {\n      if (event === undefined) return;\n      event.preventDefault();\n      const maybeIndex = getButtonIndex(event);\n      if (maybeIndex === undefined) return;\n\n      const color = selectedPalette[maybeIndex];\n      setColor(color);\n      onCancel();\n    }\n  );\n  return (\n    <Modal onClose={onCancel} heading={\"Palette\"}>\n      <Box fill pad={{ top: \"small\", bottom: \"small\" }} gap=\"small\">\n        <Box\n          direction=\"row\"\n          wrap\n          justify=\"between\"\n          alignSelf=\"center\"\n          onTouchStart={onPressDown}\n          onTouchEnd={onPressUp}\n        >\n          {Object.values(selectedPalette).map((color, index) => {\n            const isPinned = !!pinnedColors.find((pinned) =>\n              RGBColor.Equals(pinned, color)\n            );\n            return (\n              <Box\n                key={index}\n                height=\"xsmall\"\n                width=\"xsmall\"\n                pad={{ bottom: \"xsmall\" }}\n              >\n                <Button\n                  primary\n                  fill=\"vertical\"\n                  size=\"large\"\n                  key={index}\n                  data-index={index}\n                  color={color.toHex()}\n                  icon={isPinned ? <Pin /> : undefined}\n                  style={{\n                    borderRadius: \"0\",\n                    border: \"none\",\n                  }}\n                ></Button>\n              </Box>\n            );\n          })}\n        </Box>\n      </Box>\n      <Box pad={{ top: \"small\", bottom: \"small\" }} gap=\"small\">\n        <PalettePicker palette={palette} onPaletteChange={onPaletteChange} />\n      </Box>\n    </Modal>\n  );\n};\nfunction getButtonIndex(event: React.TouchEvent): number | undefined {\n  const maybeIndexString = (event.target as HTMLButtonElement).dataset.index;\n  if (!maybeIndexString) return undefined;\n\n  return parseInt(maybeIndexString, 10);\n}\n","import { useRef } from \"react\";\n\nexport const useLongPress = (\n  onLongPressComplete: (event: React.TouchEvent<HTMLDivElement>) => void,\n  duration: number,\n  onLongPressCancel?: (\n    event: React.TouchEvent<HTMLDivElement> | undefined\n  ) => void\n) => {\n  const timeout = useRef<NodeJS.Timeout>();\n  const wasLongPress = useRef(false);\n\n  const cancelTimeout = () => {\n    timeout.current && clearTimeout(timeout.current);\n    timeout.current = undefined;\n  };\n\n  const onPressDown = (event: React.TouchEvent<HTMLDivElement>) => {\n    timeout.current = setTimeout(() => {\n      wasLongPress.current = true;\n      onLongPressComplete(event);\n      cancelTimeout();\n    }, duration);\n  };\n\n  const onPressUp = (event: React.TouchEvent<HTMLDivElement>) => {\n    if (timeout.current === undefined) return;\n    cancelTimeout();\n    onLongPressCancel?.(event);\n  };\n\n  return { onPressDown, onPressUp, wasLongPress };\n};\n","import { Box, Button, FormField, Grid, Image, Select, Text } from \"grommet\";\nimport { useState } from \"react\";\nimport { LoadButton } from \"../components/LoadButton\";\nimport { RGBColor } from \"../drivers/color/src/RGBColor\";\nimport defaultImageSrc from \"../images/checker-board.png\";\nimport { Modal } from \"./Modal\";\nimport { PaletteModal } from \"./PaletteModal\";\nimport { Background } from \"../Types\";\n\nconst backgroundTypes: Background[\"type\"][] = [\n  \"checkerboard\",\n  \"color\",\n  \"image\",\n];\nexport const BackgroundImageSettings = ({\n  onCancel,\n  onSave,\n  background: outerBackgroundData,\n}: {\n  background: Background;\n  onCancel: () => void;\n  onSave: (background: Background) => void;\n}) => {\n  const [background, setBackground] = useState<Background>(outerBackgroundData);\n  const [isPaletteModalShown, setPaletteMenuShown] = useState(false);\n\n  const onBackgroundTypeChange = ({\n    option,\n  }: {\n    option: Background[\"type\"];\n  }) => {\n    setBackground({ ...background, type: option });\n  };\n\n  return (\n    <>\n      <Modal onClose={onCancel} heading={\"Background Image Settings\"}>\n        <FormField label=\"Mode\">\n          <Select\n            value={background.type}\n            options={backgroundTypes}\n            onChange={onBackgroundTypeChange}\n          />\n        </FormField>\n\n        {background.type === \"image\" && (\n          <Box gap=\"small\">\n            <FormField label=\"Image fill mode\" name=\"select\">\n              <Select\n                value={outerBackgroundData.size}\n                options={[\"cover\", \"contain\"]}\n                onChange={({ option: size }: { option: Background[\"size\"] }) =>\n                  setBackground({ ...background, size })\n                }\n              />\n            </FormField>\n\n            <Box\n              direction=\"row\"\n              gap=\"small\"\n              fill=\"horizontal\"\n              justify=\"between\"\n              pad={{ left: \"8px\" }}\n            >\n              <Text alignSelf=\"center\">Background Image</Text>\n              <LoadButton\n                setLoadedImage={(image) =>\n                  setBackground({ ...background, image })\n                }\n              />\n            </Box>\n\n            <Box width=\"small\" height=\"small\" pad=\"small\">\n              <Image\n                style={{ backgroundColor: background.color.toHex() }}\n                src={background.image?.src || defaultImageSrc}\n                fit={background.size}\n              />\n            </Box>\n          </Box>\n        )}\n\n        {background.type !== \"checkerboard\" && (\n          <Box\n            direction=\"row\"\n            gap=\"small\"\n            fill=\"horizontal\"\n            justify=\"between\"\n            pad={{ left: \"8px\" }}\n          >\n            <Text alignSelf=\"center\">Background color</Text>\n            <Button\n              size=\"small\"\n              primary\n              color={(background.color as RGBColor).toHex()}\n              label={\"Select color\"}\n              onClick={() => setPaletteMenuShown(true)}\n            />\n          </Box>\n        )}\n\n        <Grid\n          columns={{ count: 2, size: [\"auto\", \"auto\"] }}\n          gap=\"small\"\n          pad={{ top: \"medium\", bottom: \"small\" }}\n        >\n          <Button label=\"Cancel\" onClick={onCancel} />\n\n          <Button\n            primary\n            label=\"Save\"\n            onClick={() => {\n              onSave(background);\n            }}\n          />\n        </Grid>\n      </Modal>\n      {isPaletteModalShown && (\n        <PaletteModal\n          onCancel={() => setPaletteMenuShown(false)}\n          setColor={(color) => setBackground({ ...background, color })}\n        />\n      )}\n    </>\n  );\n};\n","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAYAAABytg0kAAAAG0lEQVQYV2P8/////ytXrjAwXr58+b+Ojg4DAHOVCnff1WbWAAAAAElFTkSuQmCC\"","import { Box, Button, CheckBox, Grid, Text } from \"grommet\";\nimport { useState } from \"react\";\nimport { BackgroundImageSettings } from \"./BackgroundImageSettings\";\nimport { Modal } from \"./Modal\";\nimport { Background } from \"../Types\";\n\ntype SettingsData = {\n  backgroundData: Background;\n  isDarkMode: boolean;\n  isFeedbackOn: boolean;\n};\n\nexport const SettingsModal = ({\n  onCancel,\n  onSave,\n  setDarkMode,\n  isDarkMode,\n  isFeedbackOn,\n  background,\n}: {\n  isDarkMode: boolean;\n  background: Background;\n  onCancel: () => void;\n  onSave: (settingsData: SettingsData) => void;\n  setDarkMode: (value: boolean) => void;\n  isFeedbackOn: boolean;\n}) => {\n  const [\n    isBackgroundImageSettingsShown,\n    setBackgroundImageSettingsShown,\n  ] = useState(false);\n\n  const [backgroundData, setBackgroundData] = useState<Background>(background);\n  const [innerIsFeedbackOn, setFeedbackOn] = useState(isFeedbackOn);\n\n  return (\n    <>\n      <Modal onClose={onCancel} heading={\"Settings\"}>\n        <Box gap=\"small\">\n          <Box\n            direction=\"row\"\n            gap=\"small\"\n            fill=\"horizontal\"\n            justify=\"between\"\n            pad={{ left: \"8px\" }}\n          >\n            <Text alignSelf=\"center\">Dark mode</Text>\n            <CheckBox\n              toggle\n              onChange={(event) => setDarkMode(event.target.checked)}\n              checked={isDarkMode}\n            />\n          </Box>{\" \"}\n          <Box\n            direction=\"row\"\n            gap=\"small\"\n            fill=\"horizontal\"\n            justify=\"between\"\n            pad={{ left: \"8px\" }}\n          >\n            <Text alignSelf=\"center\">Show feedback</Text>\n            <CheckBox\n              toggle\n              onChange={(event) => setFeedbackOn(event.target.checked)}\n              checked={innerIsFeedbackOn}\n            />\n          </Box>\n          <Box\n            direction=\"row\"\n            gap=\"small\"\n            fill=\"horizontal\"\n            justify=\"between\"\n            pad={{ left: \"8px\" }}\n          >\n            <Text alignSelf=\"center\">Background Image</Text>\n\n            <Button\n              size=\"small\"\n              label=\"Settings\"\n              onClick={() => setBackgroundImageSettingsShown(true)}\n            />\n          </Box>\n          <Grid\n            columns={{ count: 2, size: [\"auto\", \"auto\"] }}\n            gap=\"small\"\n            pad={{ top: \"medium\", bottom: \"small\" }}\n          >\n            <Button label=\"Cancel\" onClick={onCancel} />\n\n            <Button\n              primary\n              label=\"Save\"\n              onClick={() => {\n                onSave({\n                  backgroundData,\n                  isDarkMode,\n                  isFeedbackOn: innerIsFeedbackOn,\n                });\n              }}\n            />\n          </Grid>\n        </Box>\n      </Modal>\n      {isBackgroundImageSettingsShown && (\n        <BackgroundImageSettings\n          onCancel={() => setBackgroundImageSettingsShown(false)}\n          onSave={(background) => {\n            setBackgroundData(background);\n            setBackgroundImageSettingsShown(false);\n          }}\n          background={background}\n        />\n      )}\n    </>\n  );\n};\n","import { Grid, grommet, Grommet, Header, Main, ThemeType } from \"grommet\";\nimport { deepMerge } from \"grommet/utils\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\nimport { BodyColorPicker } from \"./components/BodyColorPicker\";\nimport { CanvasStack } from \"./components/CanvasStack\";\nimport { ControlsBanner } from \"./components/ControlsBanner\";\nimport { ControlsFeedback } from \"./components/ControlsFeedback\";\nimport { ValidDimensions } from \"./components/DimensionPicker\";\nimport { Footer } from \"./components/Footer\";\nimport { GridMode } from \"./components/Grid\";\nimport { RGBColor } from \"./drivers/color/src/RGBColor\";\nimport { UndoablePaintCanvas } from \"./drivers/paint/src/UndoablePaintCanvas\";\nimport { ConfirmModal, ConfirmModalProps } from \"./modals/ConfirmModal\";\nimport { NewPageModal } from \"./modals/NewPageModal\";\nimport { PaletteModal } from \"./modals/PaletteModal\";\nimport { SettingsModal } from \"./modals/SettingsModal\";\nimport { AvailablePalettes } from \"./PaletteDictionary\";\nimport { Background, Brushes, Controls, Tools } from \"./Types\";\n\nconst customTheme: ThemeType = {\n  icon: {\n    size: { medium: \"20px\" },\n  },\n  global: { edgeSize: { small: \"8px\" } },\n};\n\nconst mergedTheme = deepMerge(grommet, customTheme);\n\nconst defaultPalette = \"cga\";\nconst defaultColor = \"#5555ff\";\n\nconst App = () => {\n  const [pixelDimensions, setPixelDimensions] = useState<ValidDimensions>(16);\n  const [color, setColor] = useState<RGBColor>(\n    RGBColor.fromHexString(defaultColor)\n  );\n\n  const [confirmModalParameters, createModal] = useState<\n    ConfirmModalProps | undefined\n  >(undefined);\n\n  const [tool, setTool] = useState<Tools>(\"paint\");\n\n  const [background, setBackground] = useState<Background>({\n    type: \"checkerboard\",\n    image: undefined,\n    color: new RGBColor(0, 0, 0),\n    size: \"cover\",\n  });\n\n  const [brush, setToolAndBrush] = useStickyBrush(\"paint\", setTool);\n  const [control, setControl] = useState<Controls>(\"paint\");\n  const [pickerMode, setPickerMode] = useState<\n    \"history\" | \"pinned\" | \"palette\"\n  >(\"pinned\");\n  const [gridMode, setGridShown] = useState<GridMode>(\"off\");\n  const [isPaletteModalShown, setPaletteMenuShown] = useState(false);\n  const [\n    isControlsFeedbackModalShown,\n    setControlsFeedbackModalShown,\n  ] = useState(false);\n  const [palette, setPalette] = useState<AvailablePalettes>(defaultPalette);\n  const [drawImage, setDrawImage] = useState<HTMLImageElement>();\n  const [isNewPageModalShown, setCreateMenuShown] = useState(false);\n  const [isSettingsMenuShown, setSettingsMenuShown] = useState(false);\n  const [darkMode, setDarkMode] = useState(false);\n  const [isFeedbackOn, setFeedbackOn] = useState(true);\n  const [canvas, setCanvas] = useState<undefined | HTMLCanvasElement>();\n  const [pinnedColors, setPinnedColors] = useState<RGBColor[]>([]);\n  const [colorHistory, setColorHistory] = useState<RGBColor[]>([]);\n\n  const paint = useMemo(() => {\n    return new UndoablePaintCanvas(pixelDimensions);\n  }, [pixelDimensions]);\n\n  useEffect(() => {\n    if (drawImage) {\n      paint.setPixelsFromImage(drawImage);\n    } else {\n      paint.clear();\n    }\n\n    paint.drawToCanvas();\n  }, [drawImage, pixelDimensions, canvas, paint]);\n\n  const onCanvasTouch = (\n    canvas: HTMLCanvasElement,\n    event: React.TouchEvent<HTMLCanvasElement>\n  ): void => {\n    const touch = event.changedTouches[0];\n    const target = event.target as HTMLElement;\n    if (touch === undefined) {\n      throw new Error(\"Could not get touch on canvas\");\n    }\n    const coords = paint.touchToCoords(touch, target);\n    switch (tool) {\n      case \"dropper\": {\n        setTool(brush);\n        const selectedColor = paint.getColorAt(coords.quantX, coords.quantY);\n        if (selectedColor === RGBColor.NO_COLOR) break;\n        setColor(selectedColor);\n        break;\n      }\n      case \"paint\": {\n        paint.setCanvas(canvas);\n        paint.touchEvent(touch, target, color);\n        paint.drawToCanvas();\n        break;\n      }\n      case \"eraser\": {\n        paint.setCanvas(canvas);\n        paint.touchEvent(touch, target, RGBColor.NO_COLOR);\n        paint.drawToCanvas();\n        break;\n      }\n      case \"fill\": {\n        paint.setCanvas(canvas);\n        paint.fillWithColor(coords.quantX, coords.quantY, color);\n        paint.drawToCanvas();\n\n        break;\n      }\n    }\n  };\n\n  const onCanvasCreated = (canvas: HTMLCanvasElement): void => {\n    setCanvas(canvas);\n    paint.setCanvas(canvas);\n  };\n\n  const onUndoClick = () => {\n    paint.undo();\n    paint.drawToCanvas();\n  };\n\n  const onRedoClick = () => {\n    paint.redo();\n    paint.drawToCanvas();\n  };\n\n  const onPaletteButtonClick = () => setPaletteMenuShown(!isPaletteModalShown);\n  const onGridButtonClick = () => {\n    switch (gridMode) {\n      case \"off\":\n        setGridShown(\"lines\");\n        break;\n      case \"lines\":\n        setGridShown(\"dots\");\n        break;\n      case \"dots\":\n        setGridShown(\"off\");\n        break;\n    }\n  };\n\n  const onTrashClick = () =>\n    createModal({\n      onAccept: () => {\n        createModal(undefined);\n\n        paint.clear();\n        paint.drawToCanvas();\n      },\n      message: \"Are you sure you want to clear the canvas?\",\n      acceptButtonText: \"Clear\",\n      onCancel: () => {\n        createModal(undefined);\n      },\n      onClose: () => createModal(undefined),\n    });\n  const setColorAndTurnOffPicker = (color: RGBColor): void => {\n    setColor(color);\n    setTool(brush);\n  };\n\n  const isConfirmModalShown = !!confirmModalParameters;\n\n  return (\n    <Grommet\n      theme={mergedTheme}\n      style={{ height: \"100%\" }}\n      themeMode={darkMode ? \"dark\" : \"light\"}\n    >\n      <Grid\n        fill\n        areas={[\n          { name: \"header\", start: [0, 0], end: [0, 0] },\n          { name: \"canvas\", start: [0, 1], end: [0, 1] },\n          { name: \"body\", start: [0, 2], end: [0, 2] },\n          { name: \"footer\", start: [0, 3], end: [0, 3] },\n        ]}\n        columns={[\"full\"]}\n        rows={[\"auto\", \"auto\", \"flex\", \"36px\"]}\n      >\n        <Header gridArea=\"header\" justify=\"center\">\n          Pixel Pixy\n        </Header>\n        {isFeedbackOn && isControlsFeedbackModalShown && (\n          <ControlsFeedback\n            onClose={() => setControlsFeedbackModalShown(false)}\n            control={control}\n          />\n        )}\n        <CanvasStack\n          stackProps={{ gridArea: \"canvas\", interactiveChild: \"first\" }}\n          gridMode={gridMode}\n          onCanvasCreated={onCanvasCreated}\n          onCanvasTouch={onCanvasTouch}\n          pixelDimensions={pixelDimensions}\n          background={background}\n        />\n\n        <Main gridArea=\"body\" pad=\"small\" elevation=\"xsmall\">\n          <ControlsBanner\n            color={color}\n            tool={tool}\n            gridMode={gridMode}\n            onPickerModeClick={setPickerMode}\n            onToolChange={setToolAndBrush}\n            onGridButtonClick={onGridButtonClick}\n            onPaletteButtonClick={onPaletteButtonClick}\n            onRedoClick={onRedoClick}\n            onUndoClick={onUndoClick}\n            onTrashClick={onTrashClick}\n            pickerMode={pickerMode}\n            onControlsClick={(control) => {\n              setControl(control);\n              if (\n                control !== \"palette\" &&\n                control !== \"trash\" &&\n                isFeedbackOn\n              ) {\n                setControlsFeedbackModalShown(true);\n              }\n            }}\n          />\n\n          <BodyColorPicker\n            setColorHistory={setColorHistory}\n            colorHistory={colorHistory}\n            pickerMode={pickerMode}\n            color={color}\n            palette={palette}\n            pinnedColors={pinnedColors}\n            setColorAndTurnOffPicker={setColorAndTurnOffPicker}\n          />\n        </Main>\n        {canvas && (\n          <Footer\n            gridArea=\"footer\"\n            canvas={canvas}\n            onAddButtonClicked={() => setCreateMenuShown(true)}\n            setSettingsMenuShown={setSettingsMenuShown}\n          />\n        )}\n      </Grid>\n\n      {isPaletteModalShown && (\n        <PaletteModal\n          pinnedColors={pinnedColors}\n          setPinnedColors={setPinnedColors}\n          onCancel={() => setPaletteMenuShown(false)}\n          setColor={setColorAndTurnOffPicker}\n          palette={palette}\n          setPalette={setPalette}\n        />\n      )}\n\n      {isConfirmModalShown && (\n        <ConfirmModal\n          onClose={confirmModalParameters!.onClose}\n          onAccept={confirmModalParameters!.onAccept}\n          onCancel={confirmModalParameters!.onCancel}\n          cancelButtonText={confirmModalParameters!.cancelButtonText}\n          acceptButtonText={confirmModalParameters!.acceptButtonText}\n          message={confirmModalParameters!.message}\n        />\n      )}\n\n      {isNewPageModalShown && (\n        <NewPageModal\n          currentDimension={pixelDimensions}\n          onCancel={() => setCreateMenuShown(false)}\n          onCreateNew={(dimension, maybeLoadedImage) => {\n            setDrawImage(maybeLoadedImage);\n            setPixelDimensions(dimension);\n            setCreateMenuShown(false);\n          }}\n        />\n      )}\n\n      {isSettingsMenuShown && (\n        <SettingsModal\n          background={background}\n          isDarkMode={darkMode}\n          isFeedbackOn={isFeedbackOn}\n          onCancel={() => setSettingsMenuShown(false)}\n          setDarkMode={setDarkMode}\n          onSave={(settingsData) => {\n            const { backgroundData, isDarkMode, isFeedbackOn } = settingsData;\n            setFeedbackOn(isFeedbackOn);\n            setDarkMode(isDarkMode);\n            setBackground(backgroundData);\n            setSettingsMenuShown(false);\n          }}\n        />\n      )}\n    </Grommet>\n  );\n};\n\nconst useStickyBrush = (\n  defaultBrush: Brushes,\n  setTool: (tool: Tools) => void\n) => {\n  const [brush, setBrush] = useState<Brushes>(defaultBrush);\n\n  const setToolAndBrush = useCallback(\n    (tool: Tools) => {\n      switch (tool) {\n        case \"fill\": {\n          setBrush(\"fill\");\n          break;\n        }\n        case \"paint\": {\n          setBrush(\"paint\");\n          break;\n        }\n      }\n\n      setTool(tool);\n    },\n    [setTool]\n  );\n\n  return [brush, setToolAndBrush] as const;\n};\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport \"./styles/index.css\";\n\nwindow.oncontextmenu = function (event: MouseEvent) {\n  event.preventDefault();\n  event.stopPropagation();\n  return false;\n};\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}